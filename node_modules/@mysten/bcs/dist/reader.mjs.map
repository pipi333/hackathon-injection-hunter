{"version":3,"file":"reader.mjs","names":[],"sources":["../src/reader.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { ulebDecode } from './uleb.js';\n\n/**\n * Class used for reading BCS data chunk by chunk. Meant to be used\n * by some wrapper, which will make sure that data is valid and is\n * matching the desired format.\n *\n * @example\n * // data for this example is:\n * // { a: u8, b: u32, c: bool, d: u64 }\n *\n * let reader = new BcsReader(\"647f1a060001ffffe7890423c78a050102030405\");\n * let field1 = reader.read8();\n * let field2 = reader.read32();\n * let field3 = reader.read8() === '1'; // bool\n * let field4 = reader.read64();\n * // ....\n *\n * Reading vectors is another deal in bcs. To read a vector, you first need to read\n * its length using {@link readULEB}. Here's an example:\n * @example\n * // data encoded: { field: [1, 2, 3, 4, 5] }\n * let reader = new BcsReader(\"050102030405\");\n * let vec_length = reader.readULEB();\n * let elements = [];\n * for (let i = 0; i < vec_length; i++) {\n *   elements.push(reader.read8());\n * }\n * console.log(elements); // [1,2,3,4,5]\n *\n * @param {String} data HEX-encoded data (serialized BCS)\n */\nexport class BcsReader {\n\tprivate dataView: DataView;\n\tprivate bytePosition: number = 0;\n\n\t/**\n\t * @param {Uint8Array} data Data to use as a buffer.\n\t */\n\tconstructor(data: Uint8Array) {\n\t\tthis.dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);\n\t}\n\t/**\n\t * Shift current cursor position by `bytes`.\n\t *\n\t * @param {Number} bytes Number of bytes to\n\t * @returns {this} Self for possible chaining.\n\t */\n\tshift(bytes: number) {\n\t\tthis.bytePosition += bytes;\n\t\treturn this;\n\t}\n\t/**\n\t * Read U8 value from the buffer and shift cursor by 1.\n\t * @returns\n\t */\n\tread8(): number {\n\t\tconst value = this.dataView.getUint8(this.bytePosition);\n\t\tthis.shift(1);\n\t\treturn value;\n\t}\n\t/**\n\t * Read U16 value from the buffer and shift cursor by 2.\n\t * @returns\n\t */\n\tread16(): number {\n\t\tconst value = this.dataView.getUint16(this.bytePosition, true);\n\t\tthis.shift(2);\n\t\treturn value;\n\t}\n\t/**\n\t * Read U32 value from the buffer and shift cursor by 4.\n\t * @returns\n\t */\n\tread32(): number {\n\t\tconst value = this.dataView.getUint32(this.bytePosition, true);\n\t\tthis.shift(4);\n\t\treturn value;\n\t}\n\t/**\n\t * Read U64 value from the buffer and shift cursor by 8.\n\t * @returns\n\t */\n\tread64(): string {\n\t\tconst value1 = this.read32();\n\t\tconst value2 = this.read32();\n\n\t\tconst result = value2.toString(16) + value1.toString(16).padStart(8, '0');\n\n\t\treturn BigInt('0x' + result).toString(10);\n\t}\n\t/**\n\t * Read U128 value from the buffer and shift cursor by 16.\n\t */\n\tread128(): string {\n\t\tconst value1 = BigInt(this.read64());\n\t\tconst value2 = BigInt(this.read64());\n\t\tconst result = value2.toString(16) + value1.toString(16).padStart(16, '0');\n\n\t\treturn BigInt('0x' + result).toString(10);\n\t}\n\t/**\n\t * Read U128 value from the buffer and shift cursor by 32.\n\t * @returns\n\t */\n\tread256(): string {\n\t\tconst value1 = BigInt(this.read128());\n\t\tconst value2 = BigInt(this.read128());\n\t\tconst result = value2.toString(16) + value1.toString(16).padStart(32, '0');\n\n\t\treturn BigInt('0x' + result).toString(10);\n\t}\n\t/**\n\t * Read `num` number of bytes from the buffer and shift cursor by `num`.\n\t * @param num Number of bytes to read.\n\t */\n\treadBytes(num: number): Uint8Array {\n\t\tconst start = this.bytePosition + this.dataView.byteOffset;\n\t\tconst value = new Uint8Array(this.dataView.buffer, start, num);\n\n\t\tthis.shift(num);\n\n\t\treturn value;\n\t}\n\t/**\n\t * Read ULEB value - an integer of varying size. Used for enum indexes and\n\t * vector lengths.\n\t * @returns {Number} The ULEB value.\n\t */\n\treadULEB(): number {\n\t\tconst start = this.bytePosition + this.dataView.byteOffset;\n\t\tconst buffer = new Uint8Array(this.dataView.buffer, start);\n\t\tconst { value, length } = ulebDecode(buffer);\n\n\t\tthis.shift(length);\n\n\t\treturn value;\n\t}\n\t/**\n\t * Read a BCS vector: read a length and then apply function `cb` X times\n\t * where X is the length of the vector, defined as ULEB in BCS bytes.\n\t * @param cb Callback to process elements of vector.\n\t * @returns {Array<Any>} Array of the resulting values, returned by callback.\n\t */\n\treadVec(cb: (reader: BcsReader, i: number, length: number) => any): any[] {\n\t\tconst length = this.readULEB();\n\t\tconst result = [];\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tresult.push(cb(this, i, length));\n\t\t}\n\t\treturn result;\n\t}\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmCA,IAAa,YAAb,MAAuB;;;;CAOtB,YAAY,MAAkB;sBALC;AAM9B,OAAK,WAAW,IAAI,SAAS,KAAK,QAAQ,KAAK,YAAY,KAAK,WAAW;;;;;;;;CAQ5E,MAAM,OAAe;AACpB,OAAK,gBAAgB;AACrB,SAAO;;;;;;CAMR,QAAgB;EACf,MAAM,QAAQ,KAAK,SAAS,SAAS,KAAK,aAAa;AACvD,OAAK,MAAM,EAAE;AACb,SAAO;;;;;;CAMR,SAAiB;EAChB,MAAM,QAAQ,KAAK,SAAS,UAAU,KAAK,cAAc,KAAK;AAC9D,OAAK,MAAM,EAAE;AACb,SAAO;;;;;;CAMR,SAAiB;EAChB,MAAM,QAAQ,KAAK,SAAS,UAAU,KAAK,cAAc,KAAK;AAC9D,OAAK,MAAM,EAAE;AACb,SAAO;;;;;;CAMR,SAAiB;EAChB,MAAM,SAAS,KAAK,QAAQ;EAG5B,MAAM,SAFS,KAAK,QAAQ,CAEN,SAAS,GAAG,GAAG,OAAO,SAAS,GAAG,CAAC,SAAS,GAAG,IAAI;AAEzE,SAAO,OAAO,OAAO,OAAO,CAAC,SAAS,GAAG;;;;;CAK1C,UAAkB;EACjB,MAAM,SAAS,OAAO,KAAK,QAAQ,CAAC;EAEpC,MAAM,SADS,OAAO,KAAK,QAAQ,CAAC,CACd,SAAS,GAAG,GAAG,OAAO,SAAS,GAAG,CAAC,SAAS,IAAI,IAAI;AAE1E,SAAO,OAAO,OAAO,OAAO,CAAC,SAAS,GAAG;;;;;;CAM1C,UAAkB;EACjB,MAAM,SAAS,OAAO,KAAK,SAAS,CAAC;EAErC,MAAM,SADS,OAAO,KAAK,SAAS,CAAC,CACf,SAAS,GAAG,GAAG,OAAO,SAAS,GAAG,CAAC,SAAS,IAAI,IAAI;AAE1E,SAAO,OAAO,OAAO,OAAO,CAAC,SAAS,GAAG;;;;;;CAM1C,UAAU,KAAyB;EAClC,MAAM,QAAQ,KAAK,eAAe,KAAK,SAAS;EAChD,MAAM,QAAQ,IAAI,WAAW,KAAK,SAAS,QAAQ,OAAO,IAAI;AAE9D,OAAK,MAAM,IAAI;AAEf,SAAO;;;;;;;CAOR,WAAmB;EAClB,MAAM,QAAQ,KAAK,eAAe,KAAK,SAAS;EAEhD,MAAM,EAAE,OAAO,WAAW,WADX,IAAI,WAAW,KAAK,SAAS,QAAQ,MAAM,CACd;AAE5C,OAAK,MAAM,OAAO;AAElB,SAAO;;;;;;;;CAQR,QAAQ,IAAkE;EACzE,MAAM,SAAS,KAAK,UAAU;EAC9B,MAAM,SAAS,EAAE;AACjB,OAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,IAC3B,QAAO,KAAK,GAAG,MAAM,GAAG,OAAO,CAAC;AAEjC,SAAO"}