{"version":3,"file":"bcs.mjs","names":[],"sources":["../src/bcs.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { BcsTypeOptions } from './bcs-type.js';\nimport {\n\tBcsEnum,\n\tBcsStruct,\n\tBcsTuple,\n\tBcsType,\n\tbigUIntBcsType,\n\tdynamicSizeBcsType,\n\tfixedSizeBcsType,\n\tlazyBcsType,\n\tstringLikeBcsType,\n\tuIntBcsType,\n} from './bcs-type.js';\nimport type {\n\tEnumInputShape,\n\tEnumOutputShape,\n\tInferBcsInput,\n\tInferBcsType,\n\tJoinString,\n} from './types.js';\nimport { ulebEncode } from './uleb.js';\n\nfunction fixedArray<T extends BcsType<any>, Name extends string = string>(\n\tsize: number,\n\ttype: T,\n\toptions?: BcsTypeOptions<\n\t\tInferBcsType<T>[],\n\t\tIterable<InferBcsInput<T>> & { length: number },\n\t\tName\n\t>,\n): BcsType<InferBcsType<T>[], Iterable<InferBcsInput<T>> & { length: number }, Name>;\nfunction fixedArray<T, Input, Name extends string = string>(\n\tsize: number,\n\ttype: BcsType<T, Input>,\n\toptions?: BcsTypeOptions<T[], Iterable<Input> & { length: number }, Name>,\n): BcsType<T[], Iterable<Input> & { length: number }, Name>;\nfunction fixedArray<T extends BcsType<any>, Name extends string = `${T['name']}[${number}]`>(\n\tsize: number,\n\ttype: T,\n\toptions?: BcsTypeOptions<\n\t\tInferBcsType<T>[],\n\t\tIterable<InferBcsInput<T>> & { length: number },\n\t\tName\n\t>,\n): BcsType<InferBcsType<T>[], Iterable<InferBcsInput<T>> & { length: number }, Name> {\n\treturn new BcsType<InferBcsType<T>[], Iterable<InferBcsInput<T>> & { length: number }, Name>({\n\t\tread: (reader) => {\n\t\t\tconst result: InferBcsType<T>[] = new Array(size);\n\t\t\tfor (let i = 0; i < size; i++) {\n\t\t\t\tresult[i] = type.read(reader);\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\t\twrite: (value, writer) => {\n\t\t\tfor (const item of value) {\n\t\t\t\ttype.write(item, writer);\n\t\t\t}\n\t\t},\n\t\t...options,\n\t\tname: (options?.name ?? `${type.name}[${size}]`) as Name,\n\t\tvalidate: (value) => {\n\t\t\toptions?.validate?.(value);\n\t\t\tif (!value || typeof value !== 'object' || !('length' in value)) {\n\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t}\n\t\t\tif (value.length !== size) {\n\t\t\t\tthrow new TypeError(`Expected array of length ${size}, found ${value.length}`);\n\t\t\t}\n\t\t},\n\t});\n}\n\nfunction option<T extends BcsType<any>>(\n\ttype: T,\n): BcsType<InferBcsType<T> | null, InferBcsInput<T> | null | undefined, `Option<${T['name']}>`>;\nfunction option<T, Input, Name extends string = string>(\n\ttype: BcsType<T, Input, Name>,\n): BcsType<T | null, Input | null | undefined>;\nfunction option<T extends BcsType<any>>(\n\ttype: T,\n): BcsType<InferBcsType<T> | null, InferBcsInput<T> | null | undefined, `Option<${T['name']}>`> {\n\treturn bcs\n\t\t.enum(`Option<${type.name}>`, {\n\t\t\tNone: null,\n\t\t\tSome: type,\n\t\t})\n\t\t.transform({\n\t\t\tinput: (value: InferBcsInput<T> | null | undefined) => {\n\t\t\t\tif (value == null) {\n\t\t\t\t\treturn { None: true };\n\t\t\t\t}\n\n\t\t\t\treturn { Some: value };\n\t\t\t},\n\t\t\toutput: (value) => {\n\t\t\t\tif (value.$kind === 'Some') {\n\t\t\t\t\treturn value.Some as InferBcsType<T>;\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\t\t\t},\n\t\t});\n}\n\nfunction vector<T extends BcsType<any>, Name extends string = `vector<${T['name']}>`>(\n\ttype: T,\n\toptions?: BcsTypeOptions<\n\t\tInferBcsType<T>[],\n\t\tIterable<InferBcsInput<T>> & { length: number },\n\t\tName\n\t>,\n): BcsType<InferBcsType<T>[], Iterable<InferBcsInput<T>> & { length: number }, Name>;\nfunction vector<T, Input, Name extends string = string>(\n\ttype: BcsType<T, Input, Name>,\n\toptions?: BcsTypeOptions<T[], Iterable<Input> & { length: number }, `vector<${Name}>`>,\n): BcsType<T[], Iterable<Input> & { length: number }, `vector<${Name}>`>;\nfunction vector<T extends BcsType<any>, Name extends string = `vector<${T['name']}>`>(\n\ttype: T,\n\toptions?: BcsTypeOptions<\n\t\tInferBcsType<T>[],\n\t\tIterable<InferBcsInput<T>> & { length: number },\n\t\tName\n\t>,\n): BcsType<InferBcsType<T>[], Iterable<InferBcsInput<T>> & { length: number }, Name> {\n\treturn new BcsType<InferBcsType<T>[], Iterable<InferBcsInput<T>> & { length: number }, Name>({\n\t\tread: (reader) => {\n\t\t\tconst length = reader.readULEB();\n\t\t\tconst result: InferBcsType<T>[] = new Array(length);\n\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\tresult[i] = type.read(reader);\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\t\twrite: (value, writer) => {\n\t\t\twriter.writeULEB(value.length);\n\t\t\tfor (const item of value) {\n\t\t\t\ttype.write(item, writer);\n\t\t\t}\n\t\t},\n\t\t...options,\n\t\tname: (options?.name ?? `vector<${type.name}>`) as Name,\n\t\tvalidate: (value) => {\n\t\t\toptions?.validate?.(value);\n\t\t\tif (!value || typeof value !== 'object' || !('length' in value)) {\n\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t}\n\t\t},\n\t});\n}\n\n/**\n * Compares two byte arrays using lexicographic ordering.\n * This matches Rust's Ord implementation for Vec<u8>/[u8] which is used for BTreeMap key ordering.\n * Comparison is done byte-by-byte first, then by length if all compared bytes are equal.\n */\nexport function compareBcsBytes(a: Uint8Array, b: Uint8Array): number {\n\tfor (let i = 0; i < Math.min(a.length, b.length); i++) {\n\t\tif (a[i] !== b[i]) {\n\t\t\treturn a[i] - b[i];\n\t\t}\n\t}\n\n\treturn a.length - b.length;\n}\n\nfunction map<K extends BcsType<any>, V extends BcsType<any>>(\n\tkeyType: K,\n\tvalueType: V,\n): BcsType<\n\tMap<InferBcsType<K>, InferBcsType<V>>,\n\tMap<InferBcsInput<K>, InferBcsInput<V>>,\n\t`Map<${K['name']}, ${V['name']}>`\n>;\nfunction map<K, V, InputK = K, InputV = V>(\n\tkeyType: BcsType<K, InputK>,\n\tvalueType: BcsType<V, InputV>,\n): BcsType<Map<K, V>, Map<InputK, InputV>, `Map<${string}, ${string}>`>;\nfunction map<K extends BcsType<any>, V extends BcsType<any>>(\n\tkeyType: K,\n\tvalueType: V,\n): BcsType<\n\tMap<InferBcsType<K>, InferBcsType<V>>,\n\tMap<InferBcsInput<K>, InferBcsInput<V>>,\n\t`Map<${K['name']}, ${V['name']}>`\n> {\n\treturn new BcsType({\n\t\tname: `Map<${keyType.name}, ${valueType.name}>`,\n\t\tread: (reader) => {\n\t\t\tconst length = reader.readULEB();\n\t\t\tconst result = new Map<InferBcsType<K>, InferBcsType<V>>();\n\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\tresult.set(keyType.read(reader), valueType.read(reader));\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\t\twrite: (value, writer) => {\n\t\t\tconst entries = [...value.entries()].map(\n\t\t\t\t([key, val]) => [keyType.serialize(key).toBytes(), val] as const,\n\t\t\t);\n\t\t\tentries.sort(([a], [b]) => compareBcsBytes(a, b));\n\n\t\t\twriter.writeULEB(entries.length);\n\t\t\tfor (const [keyBytes, val] of entries) {\n\t\t\t\twriter.writeBytes(keyBytes);\n\t\t\t\tvalueType.write(val, writer);\n\t\t\t}\n\t\t},\n\t});\n}\n\nexport const bcs = {\n\t/**\n\t * Creates a BcsType that can be used to read and write an 8-bit unsigned integer.\n\t * @example\n\t * bcs.u8().serialize(255).toBytes() // Uint8Array [ 255 ]\n\t */\n\tu8(options?: BcsTypeOptions<number>) {\n\t\treturn uIntBcsType({\n\t\t\treadMethod: 'read8',\n\t\t\twriteMethod: 'write8',\n\t\t\tsize: 1,\n\t\t\tmaxValue: 2 ** 8 - 1,\n\t\t\t...options,\n\t\t\tname: (options?.name ?? 'u8') as 'u8',\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 16-bit unsigned integer.\n\t * @example\n\t * bcs.u16().serialize(65535).toBytes() // Uint8Array [ 255, 255 ]\n\t */\n\tu16(options?: BcsTypeOptions<number>) {\n\t\treturn uIntBcsType({\n\t\t\treadMethod: 'read16',\n\t\t\twriteMethod: 'write16',\n\t\t\tsize: 2,\n\t\t\tmaxValue: 2 ** 16 - 1,\n\t\t\t...options,\n\t\t\tname: (options?.name ?? 'u16') as 'u16',\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 32-bit unsigned integer.\n\t * @example\n\t * bcs.u32().serialize(4294967295).toBytes() // Uint8Array [ 255, 255, 255, 255 ]\n\t */\n\tu32(options?: BcsTypeOptions<number>) {\n\t\treturn uIntBcsType({\n\t\t\treadMethod: 'read32',\n\t\t\twriteMethod: 'write32',\n\t\t\tsize: 4,\n\t\t\tmaxValue: 2 ** 32 - 1,\n\t\t\t...options,\n\t\t\tname: (options?.name ?? 'u32') as 'u32',\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 64-bit unsigned integer.\n\t * @example\n\t * bcs.u64().serialize(1).toBytes() // Uint8Array [ 1, 0, 0, 0, 0, 0, 0, 0 ]\n\t */\n\tu64(options?: BcsTypeOptions<string, number | bigint | string>) {\n\t\treturn bigUIntBcsType({\n\t\t\treadMethod: 'read64',\n\t\t\twriteMethod: 'write64',\n\t\t\tsize: 8,\n\t\t\tmaxValue: 2n ** 64n - 1n,\n\t\t\t...options,\n\t\t\tname: (options?.name ?? 'u64') as 'u64',\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 128-bit unsigned integer.\n\t * @example\n\t * bcs.u128().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n\t */\n\tu128(options?: BcsTypeOptions<string, number | bigint | string>) {\n\t\treturn bigUIntBcsType({\n\t\t\treadMethod: 'read128',\n\t\t\twriteMethod: 'write128',\n\t\t\tsize: 16,\n\t\t\tmaxValue: 2n ** 128n - 1n,\n\t\t\t...options,\n\t\t\tname: (options?.name ?? 'u128') as 'u128',\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 256-bit unsigned integer.\n\t * @example\n\t * bcs.u256().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n\t */\n\tu256(options?: BcsTypeOptions<string, number | bigint | string>) {\n\t\treturn bigUIntBcsType({\n\t\t\treadMethod: 'read256',\n\t\t\twriteMethod: 'write256',\n\t\t\tsize: 32,\n\t\t\tmaxValue: 2n ** 256n - 1n,\n\t\t\t...options,\n\t\t\tname: (options?.name ?? 'u256') as 'u256',\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write boolean values.\n\t * @example\n\t * bcs.bool().serialize(true).toBytes() // Uint8Array [ 1 ]\n\t */\n\tbool(options?: BcsTypeOptions<boolean>) {\n\t\treturn fixedSizeBcsType({\n\t\t\tsize: 1,\n\t\t\tread: (reader) => reader.read8() === 1,\n\t\t\twrite: (value, writer) => writer.write8(value ? 1 : 0),\n\t\t\t...options,\n\t\t\tname: (options?.name ?? 'bool') as 'bool',\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (typeof value !== 'boolean') {\n\t\t\t\t\tthrow new TypeError(`Expected boolean, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write unsigned LEB encoded integers\n\t * @example\n\t *\n\t */\n\tuleb128(options?: BcsTypeOptions<number>) {\n\t\treturn dynamicSizeBcsType({\n\t\t\tread: (reader) => reader.readULEB(),\n\t\t\tserialize: (value) => {\n\t\t\t\treturn Uint8Array.from(ulebEncode(value));\n\t\t\t},\n\t\t\t...options,\n\t\t\tname: (options?.name ?? 'uleb128') as 'uleb128',\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a fixed length byte array\n\t * @param size The number of bytes this types represents\n\t * @example\n\t * bcs.bytes(3).serialize(new Uint8Array([1, 2, 3])).toBytes() // Uint8Array [1, 2, 3]\n\t */\n\tbytes<T extends number>(size: T, options?: BcsTypeOptions<Uint8Array, Iterable<number>>) {\n\t\treturn fixedSizeBcsType<Uint8Array, Iterable<number>, `bytes[${T}]`>({\n\t\t\tsize,\n\t\t\tread: (reader) => reader.readBytes(size),\n\t\t\twrite: (value, writer) => {\n\t\t\t\twriter.writeBytes(new Uint8Array(value));\n\t\t\t},\n\t\t\t...options,\n\t\t\tname: (options?.name ?? `bytes[${size}]`) as `bytes[${T}]`,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!value || typeof value !== 'object' || !('length' in value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t\tif (value.length !== size) {\n\t\t\t\t\tthrow new TypeError(`Expected array of length ${size}, found ${value.length}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a variable length byte array\n\t *\n\t * @example\n\t * bcs.byteVector().serialize([1, 2, 3]).toBytes() // Uint8Array [3, 1, 2, 3]\n\t */\n\tbyteVector(options?: BcsTypeOptions<Uint8Array, Iterable<number>>) {\n\t\treturn new BcsType<Uint8Array, Iterable<number>, 'vector<u8>'>({\n\t\t\tread: (reader) => {\n\t\t\t\tconst length = reader.readULEB();\n\n\t\t\t\treturn reader.readBytes(length);\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tconst array = new Uint8Array(value);\n\t\t\t\twriter.writeULEB(array.length);\n\t\t\t\twriter.writeBytes(array);\n\t\t\t},\n\t\t\t...options,\n\t\t\tname: (options?.name ?? 'vector<u8>') as 'vector<u8>',\n\t\t\tserializedSize: (value) => {\n\t\t\t\tconst length = 'length' in value ? (value.length as number) : null;\n\t\t\t\treturn length == null ? null : ulebEncode(length).length + length;\n\t\t\t},\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!value || typeof value !== 'object' || !('length' in value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can ser/de string values.  Strings will be UTF-8 encoded\n\t * @example\n\t * bcs.string().serialize('a').toBytes() // Uint8Array [ 1, 97 ]\n\t */\n\tstring(options?: BcsTypeOptions<string>) {\n\t\treturn stringLikeBcsType({\n\t\t\ttoBytes: (value) => new TextEncoder().encode(value),\n\t\t\tfromBytes: (bytes) => new TextDecoder().decode(bytes),\n\t\t\t...options,\n\t\t\tname: (options?.name ?? 'string') as 'string',\n\t\t});\n\t},\n\t/**\n\t * Creates a BcsType that represents a fixed length array of a given type\n\t * @param size The number of elements in the array\n\t * @param type The BcsType of each element in the array\n\t * @example\n\t * bcs.fixedArray(3, bcs.u8()).serialize([1, 2, 3]).toBytes() // Uint8Array [ 1, 2, 3 ]\n\t */\n\tfixedArray,\n\n\t/**\n\t * Creates a BcsType representing an optional value\n\t * @param type The BcsType of the optional value\n\t * @example\n\t * bcs.option(bcs.u8()).serialize(null).toBytes() // Uint8Array [ 0 ]\n\t * bcs.option(bcs.u8()).serialize(1).toBytes() // Uint8Array [ 1, 1 ]\n\t */\n\toption,\n\n\t/**\n\t * Creates a BcsType representing a variable length vector of a given type\n\t * @param type The BcsType of each element in the vector\n\t *\n\t * @example\n\t * bcs.vector(bcs.u8()).toBytes([1, 2, 3]) // Uint8Array [ 3, 1, 2, 3 ]\n\t */\n\tvector,\n\n\t/**\n\t * Creates a BcsType representing a tuple of a given set of types\n\t * @param types The BcsTypes for each element in the tuple\n\t *\n\t * @example\n\t * const tuple = bcs.tuple([bcs.u8(), bcs.string(), bcs.bool()])\n\t * tuple.serialize([1, 'a', true]).toBytes() // Uint8Array [ 1, 1, 97, 1 ]\n\t */\n\ttuple<\n\t\tconst T extends readonly BcsType<any, any>[],\n\t\tconst Name extends string =\n\t\t\t`(${JoinString<{ [K in keyof T]: T[K] extends BcsType<any, any, infer T> ? T : never }, ', '>})`,\n\t>(\n\t\tfields: T,\n\t\toptions?: BcsTypeOptions<\n\t\t\t{\n\t\t\t\t-readonly [K in keyof T]: T[K] extends BcsType<infer T, any> ? T : never;\n\t\t\t},\n\t\t\t{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer T> ? T : never;\n\t\t\t},\n\t\t\tName\n\t\t>,\n\t) {\n\t\treturn new BcsTuple<T, Name>({\n\t\t\tfields,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a struct of a given set of fields\n\t * @param name The name of the struct\n\t * @param fields The fields of the struct. The order of the fields affects how data is serialized and deserialized\n\t *\n\t * @example\n\t * const struct = bcs.struct('MyStruct', {\n\t *  a: bcs.u8(),\n\t *  b: bcs.string(),\n\t * })\n\t * struct.serialize({ a: 1, b: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n\t */\n\tstruct<T extends Record<string, BcsType<any>>, const Name extends string = string>(\n\t\tname: Name,\n\t\tfields: T,\n\t\toptions?: Omit<\n\t\t\tBcsTypeOptions<\n\t\t\t\t{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never;\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U> ? U : never;\n\t\t\t\t}\n\t\t\t>,\n\t\t\t'name'\n\t\t>,\n\t) {\n\t\treturn new BcsStruct<T>({\n\t\t\tname,\n\t\t\tfields,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing an enum of a given set of options\n\t * @param name The name of the enum\n\t * @param values The values of the enum. The order of the values affects how data is serialized and deserialized.\n\t * null can be used to represent a variant with no data.\n\t *\n\t * @example\n\t * const enum = bcs.enum('MyEnum', {\n\t *   A: bcs.u8(),\n\t *   B: bcs.string(),\n\t *   C: null,\n\t * })\n\t * enum.serialize({ A: 1 }).toBytes() // Uint8Array [ 0, 1 ]\n\t * enum.serialize({ B: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n\t * enum.serialize({ C: true }).toBytes() // Uint8Array [ 2 ]\n\t */\n\tenum<T extends Record<string, BcsType<any> | null>, const Name extends string = string>(\n\t\tname: Name,\n\t\tfields: T,\n\t\toptions?: Omit<\n\t\t\tBcsTypeOptions<\n\t\t\t\tEnumOutputShape<{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any, any> ? U : true;\n\t\t\t\t}>,\n\t\t\t\tEnumInputShape<{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U, any> ? U : boolean | object | null;\n\t\t\t\t}>,\n\t\t\t\tName\n\t\t\t>,\n\t\t\t'name'\n\t\t>,\n\t) {\n\t\treturn new BcsEnum<T, Name>({\n\t\t\tname,\n\t\t\tfields,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a map of a given key and value type\n\t * @param keyType The BcsType of the key\n\t * @param valueType The BcsType of the value\n\t * @example\n\t * const map = bcs.map(bcs.u8(), bcs.string())\n\t * map.serialize(new Map([[2, 'a']])).toBytes() // Uint8Array [ 1, 2, 1, 97 ]\n\t */\n\tmap,\n\n\t/**\n\t * Creates a BcsType that wraps another BcsType which is lazily evaluated. This is useful for creating recursive types.\n\t * @param cb A callback that returns the BcsType\n\t */\n\tlazy<T extends BcsType<any>>(cb: () => T): T {\n\t\treturn lazyBcsType(cb) as T;\n\t},\n};\n"],"mappings":"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"}