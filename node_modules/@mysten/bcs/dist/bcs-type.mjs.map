{"version":3,"file":"bcs-type.mjs","names":["#write","#serialize","options","#schema","#bytes","name"],"sources":["../src/bcs-type.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase58, fromBase64, toBase58, toBase64, fromHex, toHex } from '@mysten/utils';\nimport { BcsReader } from './reader.js';\nimport { ulebEncode } from './uleb.js';\nimport type { BcsWriterOptions } from './writer.js';\nimport { BcsWriter } from './writer.js';\nimport type { EnumInputShape, EnumOutputShape, JoinString } from './types.js';\n\nexport interface BcsTypeOptions<T, Input = T, Name extends string = string> {\n\tname?: Name;\n\tvalidate?: (value: Input) => void;\n}\n\nexport class BcsType<T, Input = T, const Name extends string = string> {\n\t$inferType!: T;\n\t$inferInput!: Input;\n\tname: Name;\n\tread: (reader: BcsReader) => T;\n\tserializedSize: (value: Input, options?: BcsWriterOptions) => number | null;\n\tvalidate: (value: Input) => void;\n\t#write: (value: Input, writer: BcsWriter) => void;\n\t#serialize: (value: Input, options?: BcsWriterOptions) => Uint8Array<ArrayBuffer>;\n\n\tconstructor(\n\t\toptions: {\n\t\t\tname: Name;\n\t\t\tread: (reader: BcsReader) => T;\n\t\t\twrite: (value: Input, writer: BcsWriter) => void;\n\t\t\tserialize?: (value: Input, options?: BcsWriterOptions) => Uint8Array<ArrayBuffer>;\n\t\t\tserializedSize?: (value: Input) => number | null;\n\t\t\tvalidate?: (value: Input) => void;\n\t\t} & BcsTypeOptions<T, Input, Name>,\n\t) {\n\t\tthis.name = options.name;\n\t\tthis.read = options.read;\n\t\tthis.serializedSize = options.serializedSize ?? (() => null);\n\t\tthis.#write = options.write;\n\t\tthis.#serialize =\n\t\t\toptions.serialize ??\n\t\t\t((value, options) => {\n\t\t\t\tconst writer = new BcsWriter({\n\t\t\t\t\tinitialSize: this.serializedSize(value) ?? undefined,\n\t\t\t\t\t...options,\n\t\t\t\t});\n\t\t\t\tthis.#write(value, writer);\n\t\t\t\treturn writer.toBytes();\n\t\t\t});\n\n\t\tthis.validate = options.validate ?? (() => {});\n\t}\n\n\twrite(value: Input, writer: BcsWriter) {\n\t\tthis.validate(value);\n\t\tthis.#write(value, writer);\n\t}\n\n\tserialize(value: Input, options?: BcsWriterOptions) {\n\t\tthis.validate(value);\n\t\treturn new SerializedBcs(this, this.#serialize(value, options));\n\t}\n\n\tparse(bytes: Uint8Array): T {\n\t\tconst reader = new BcsReader(bytes);\n\t\treturn this.read(reader);\n\t}\n\n\tfromHex(hex: string) {\n\t\treturn this.parse(fromHex(hex));\n\t}\n\n\tfromBase58(b64: string) {\n\t\treturn this.parse(fromBase58(b64));\n\t}\n\n\tfromBase64(b64: string) {\n\t\treturn this.parse(fromBase64(b64));\n\t}\n\n\ttransform<T2 = T, Input2 = Input, NewName extends string = Name>({\n\t\tname,\n\t\tinput,\n\t\toutput,\n\t\tvalidate,\n\t}: {\n\t\tinput?: (val: Input2) => Input;\n\t\toutput?: (value: T) => T2;\n\t} & BcsTypeOptions<T2, Input2, NewName>) {\n\t\treturn new BcsType<T2, Input2, NewName>({\n\t\t\tname: (name ?? this.name) as NewName,\n\t\t\tread: (reader) => (output ? output(this.read(reader)) : (this.read(reader) as never)),\n\t\t\twrite: (value, writer) => this.#write(input ? input(value) : (value as never), writer),\n\t\t\tserializedSize: (value) => this.serializedSize(input ? input(value) : (value as never)),\n\t\t\tserialize: (value, options) =>\n\t\t\t\tthis.#serialize(input ? input(value) : (value as never), options),\n\t\t\tvalidate: (value) => {\n\t\t\t\tvalidate?.(value);\n\t\t\t\tthis.validate(input ? input(value) : (value as never));\n\t\t\t},\n\t\t});\n\t}\n}\n\nconst SERIALIZED_BCS_BRAND = Symbol.for('@mysten/serialized-bcs') as never;\nexport function isSerializedBcs(obj: unknown): obj is SerializedBcs<unknown> {\n\treturn !!obj && typeof obj === 'object' && (obj as any)[SERIALIZED_BCS_BRAND] === true;\n}\n\nexport class SerializedBcs<T, Input = T> {\n\t#schema: BcsType<T, Input>;\n\t#bytes: Uint8Array<ArrayBuffer>;\n\n\t// Used to brand SerializedBcs so that they can be identified, even between multiple copies\n\t// of the @mysten/bcs package are installed\n\tget [SERIALIZED_BCS_BRAND]() {\n\t\treturn true;\n\t}\n\n\tconstructor(schema: BcsType<T, Input>, bytes: Uint8Array<ArrayBuffer>) {\n\t\tthis.#schema = schema;\n\t\tthis.#bytes = bytes;\n\t}\n\n\ttoBytes() {\n\t\treturn this.#bytes;\n\t}\n\n\ttoHex() {\n\t\treturn toHex(this.#bytes);\n\t}\n\n\ttoBase64() {\n\t\treturn toBase64(this.#bytes);\n\t}\n\n\ttoBase58() {\n\t\treturn toBase58(this.#bytes);\n\t}\n\n\tparse() {\n\t\treturn this.#schema.parse(this.#bytes);\n\t}\n}\n\nexport function fixedSizeBcsType<T, Input = T, const Name extends string = string>({\n\tsize,\n\t...options\n}: {\n\tname: Name;\n\tsize: number;\n\tread: (reader: BcsReader) => T;\n\twrite: (value: Input, writer: BcsWriter) => void;\n} & BcsTypeOptions<T, Input, Name>) {\n\treturn new BcsType<T, Input, Name>({\n\t\t...options,\n\t\tserializedSize: () => size,\n\t});\n}\n\nexport function uIntBcsType<const Name extends string = string>({\n\treadMethod,\n\twriteMethod,\n\t...options\n}: {\n\tname: Name;\n\tsize: number;\n\treadMethod: `read${8 | 16 | 32}`;\n\twriteMethod: `write${8 | 16 | 32}`;\n\tmaxValue: number;\n} & BcsTypeOptions<number, number, Name>) {\n\treturn fixedSizeBcsType<number, number, Name>({\n\t\t...options,\n\t\tread: (reader) => reader[readMethod](),\n\t\twrite: (value, writer) => writer[writeMethod](value),\n\t\tvalidate: (value) => {\n\t\t\tif (value < 0 || value > options.maxValue) {\n\t\t\t\tthrow new TypeError(\n\t\t\t\t\t`Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`,\n\t\t\t\t);\n\t\t\t}\n\t\t\toptions.validate?.(value);\n\t\t},\n\t});\n}\n\nexport function bigUIntBcsType<const Name extends string = string>({\n\treadMethod,\n\twriteMethod,\n\t...options\n}: {\n\tname: Name;\n\tsize: number;\n\treadMethod: `read${64 | 128 | 256}`;\n\twriteMethod: `write${64 | 128 | 256}`;\n\tmaxValue: bigint;\n} & BcsTypeOptions<string, string | number | bigint>) {\n\treturn fixedSizeBcsType<string, string | number | bigint, Name>({\n\t\t...options,\n\t\tread: (reader) => reader[readMethod](),\n\t\twrite: (value, writer) => writer[writeMethod](BigInt(value)),\n\t\tvalidate: (val) => {\n\t\t\tconst value = BigInt(val);\n\t\t\tif (value < 0 || value > options.maxValue) {\n\t\t\t\tthrow new TypeError(\n\t\t\t\t\t`Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`,\n\t\t\t\t);\n\t\t\t}\n\t\t\toptions.validate?.(value);\n\t\t},\n\t});\n}\n\nexport function dynamicSizeBcsType<T, Input = T, const Name extends string = string>({\n\tserialize,\n\t...options\n}: {\n\tname: Name;\n\tread: (reader: BcsReader) => T;\n\tserialize: (value: Input, options?: BcsWriterOptions) => Uint8Array<ArrayBuffer>;\n} & BcsTypeOptions<T, Input>) {\n\tconst type = new BcsType<T, Input>({\n\t\t...options,\n\t\tserialize,\n\t\twrite: (value, writer) => {\n\t\t\tfor (const byte of type.serialize(value).toBytes()) {\n\t\t\t\twriter.write8(byte);\n\t\t\t}\n\t\t},\n\t});\n\n\treturn type;\n}\n\nexport function stringLikeBcsType<const Name extends string = string>({\n\ttoBytes,\n\tfromBytes,\n\t...options\n}: {\n\tname: Name;\n\ttoBytes: (value: string) => Uint8Array;\n\tfromBytes: (bytes: Uint8Array) => string;\n\tserializedSize?: (value: string) => number | null;\n} & BcsTypeOptions<string, string, Name>) {\n\treturn new BcsType<string, string, Name>({\n\t\t...options,\n\t\tread: (reader) => {\n\t\t\tconst length = reader.readULEB();\n\t\t\tconst bytes = reader.readBytes(length);\n\n\t\t\treturn fromBytes(bytes);\n\t\t},\n\t\twrite: (hex, writer) => {\n\t\t\tconst bytes = toBytes(hex);\n\t\t\twriter.writeULEB(bytes.length);\n\t\t\tfor (let i = 0; i < bytes.length; i++) {\n\t\t\t\twriter.write8(bytes[i]);\n\t\t\t}\n\t\t},\n\t\tserialize: (value) => {\n\t\t\tconst bytes = toBytes(value);\n\t\t\tconst size = ulebEncode(bytes.length);\n\t\t\tconst result = new Uint8Array(size.length + bytes.length);\n\t\t\tresult.set(size, 0);\n\t\t\tresult.set(bytes, size.length);\n\n\t\t\treturn result;\n\t\t},\n\t\tvalidate: (value) => {\n\t\t\tif (typeof value !== 'string') {\n\t\t\t\tthrow new TypeError(`Invalid ${options.name} value: ${value}. Expected string`);\n\t\t\t}\n\t\t\toptions.validate?.(value);\n\t\t},\n\t});\n}\n\nexport function lazyBcsType<T, Input>(cb: () => BcsType<T, Input>) {\n\tlet lazyType: BcsType<T, Input> | null = null;\n\tfunction getType() {\n\t\tif (!lazyType) {\n\t\t\tlazyType = cb();\n\t\t}\n\t\treturn lazyType;\n\t}\n\n\treturn new BcsType<T, Input>({\n\t\tname: 'lazy' as never,\n\t\tread: (data) => getType().read(data),\n\t\tserializedSize: (value) => getType().serializedSize(value),\n\t\twrite: (value, writer) => getType().write(value, writer),\n\t\tserialize: (value, options) => getType().serialize(value, options).toBytes(),\n\t});\n}\n\nexport interface BcsStructOptions<\n\tT extends Record<string, BcsType<any>>,\n\tName extends string = string,\n> extends Omit<\n\tBcsTypeOptions<\n\t\t{\n\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never;\n\t\t},\n\t\t{\n\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U> ? U : never;\n\t\t},\n\t\tName\n\t>,\n\t'name'\n> {\n\tname: Name;\n\tfields: T;\n}\n\nexport class BcsStruct<\n\tT extends Record<string, BcsType<any>>,\n\tconst Name extends string = string,\n> extends BcsType<\n\t{\n\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never;\n\t},\n\t{\n\t\t[K in keyof T]: T[K] extends BcsType<any, infer U> ? U : never;\n\t},\n\tName\n> {\n\tconstructor({ name, fields, ...options }: BcsStructOptions<T, Name>) {\n\t\tconst canonicalOrder = Object.entries(fields);\n\n\t\tsuper({\n\t\t\tname,\n\t\t\tserializedSize: (values) => {\n\t\t\t\tlet total = 0;\n\t\t\t\tfor (const [field, type] of canonicalOrder) {\n\t\t\t\t\tconst size = type.serializedSize(values[field]);\n\t\t\t\t\tif (size == null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t\ttotal += size;\n\t\t\t\t}\n\n\t\t\t\treturn total;\n\t\t\t},\n\t\t\tread: (reader) => {\n\t\t\t\tconst result: Record<string, unknown> = {};\n\t\t\t\tfor (const [field, type] of canonicalOrder) {\n\t\t\t\t\tresult[field] = type.read(reader);\n\t\t\t\t}\n\n\t\t\t\treturn result as never;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tfor (const [field, type] of canonicalOrder) {\n\t\t\t\t\ttype.write(value[field], writer);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (typeof value !== 'object' || value == null) {\n\t\t\t\t\tthrow new TypeError(`Expected object, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t}\n}\n\nexport interface BcsEnumOptions<\n\tT extends Record<string, BcsType<any> | null>,\n\tName extends string = string,\n> extends Omit<\n\tBcsTypeOptions<\n\t\tEnumOutputShape<{\n\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any, any> ? U : true;\n\t\t}>,\n\t\tEnumInputShape<{\n\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U, any> ? U : boolean | object | null;\n\t\t}>,\n\t\tName\n\t>,\n\t'name'\n> {\n\tname: Name;\n\tfields: T;\n}\n\nexport class BcsEnum<\n\tT extends Record<string, BcsType<any> | null>,\n\tconst Name extends string = string,\n> extends BcsType<\n\tEnumOutputShape<{\n\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : true;\n\t}>,\n\tEnumInputShape<{\n\t\t[K in keyof T]: T[K] extends BcsType<any, infer U, any> ? U : boolean | object | null;\n\t}>,\n\tName\n> {\n\tconstructor({ fields, ...options }: BcsEnumOptions<T, Name>) {\n\t\tconst canonicalOrder = Object.entries(fields as object);\n\t\tsuper({\n\t\t\tread: (reader) => {\n\t\t\t\tconst index = reader.readULEB();\n\n\t\t\t\tconst enumEntry = canonicalOrder[index];\n\t\t\t\tif (!enumEntry) {\n\t\t\t\t\tthrow new TypeError(`Unknown value ${index} for enum ${options.name}`);\n\t\t\t\t}\n\n\t\t\t\tconst [kind, type] = enumEntry;\n\n\t\t\t\treturn {\n\t\t\t\t\t[kind]: type?.read(reader) ?? true,\n\t\t\t\t\t$kind: kind,\n\t\t\t\t} as never;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tconst [name, val] = Object.entries(value).filter(([name]) =>\n\t\t\t\t\tObject.hasOwn(fields, name),\n\t\t\t\t)[0];\n\n\t\t\t\tfor (let i = 0; i < canonicalOrder.length; i++) {\n\t\t\t\t\tconst [optionName, optionType] = canonicalOrder[i];\n\t\t\t\t\tif (optionName === name) {\n\t\t\t\t\t\twriter.writeULEB(i);\n\t\t\t\t\t\toptionType?.write(val, writer);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (typeof value !== 'object' || value == null) {\n\t\t\t\t\tthrow new TypeError(`Expected object, found ${typeof value}`);\n\t\t\t\t}\n\n\t\t\t\tconst keys = Object.keys(value).filter(\n\t\t\t\t\t(k) => value[k] !== undefined && Object.hasOwn(fields, k),\n\t\t\t\t);\n\n\t\t\t\tif (keys.length !== 1) {\n\t\t\t\t\tthrow new TypeError(\n\t\t\t\t\t\t`Expected object with one key, but found ${keys.length} for type ${options.name}}`,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tconst [variant] = keys;\n\n\t\t\t\tif (!Object.hasOwn(fields, variant)) {\n\t\t\t\t\tthrow new TypeError(`Invalid enum variant ${variant}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t}\n}\n\nexport interface BcsTupleOptions<\n\tT extends readonly BcsType<any>[],\n\tName extends string,\n> extends Omit<\n\tBcsTypeOptions<\n\t\t{\n\t\t\t-readonly [K in keyof T]: T[K] extends BcsType<infer T, any> ? T : never;\n\t\t},\n\t\t{\n\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer T> ? T : never;\n\t\t},\n\t\tName\n\t>,\n\t'name'\n> {\n\tname?: Name;\n\tfields: T;\n}\n\nexport class BcsTuple<\n\tconst T extends readonly BcsType<any>[],\n\tconst Name extends string =\n\t\t`(${JoinString<{ [K in keyof T]: T[K] extends BcsType<any, any, infer T> ? T : never }, ', '>})`,\n> extends BcsType<\n\t{\n\t\t-readonly [K in keyof T]: T[K] extends BcsType<infer T, any> ? T : never;\n\t},\n\t{\n\t\t[K in keyof T]: T[K] extends BcsType<any, infer T> ? T : never;\n\t},\n\tName\n> {\n\tconstructor({ fields, name, ...options }: BcsTupleOptions<T, Name>) {\n\t\tsuper({\n\t\t\tname: name ?? (`(${fields.map((t) => t.name).join(', ')})` as never),\n\t\t\tserializedSize: (values) => {\n\t\t\t\tlet total = 0;\n\t\t\t\tfor (let i = 0; i < fields.length; i++) {\n\t\t\t\t\tconst size = fields[i].serializedSize(values[i]);\n\t\t\t\t\tif (size == null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t\ttotal += size;\n\t\t\t\t}\n\n\t\t\t\treturn total;\n\t\t\t},\n\t\t\tread: (reader) => {\n\t\t\t\tconst result: unknown[] = [];\n\t\t\t\tfor (const field of fields) {\n\t\t\t\t\tresult.push(field.read(reader));\n\t\t\t\t}\n\t\t\t\treturn result as never;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tfor (let i = 0; i < fields.length; i++) {\n\t\t\t\t\tfields[i].write(value[i], writer);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!Array.isArray(value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t\tif (value.length !== fields.length) {\n\t\t\t\t\tthrow new TypeError(`Expected array of length ${fields.length}, found ${value.length}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t}\n}\n"],"mappings":"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"}