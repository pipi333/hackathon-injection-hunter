{"version":3,"file":"sui-types.mjs","names":[],"sources":["../../src/utils/sui-types.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase58, splitGenericParameters } from '@mysten/bcs';\n\nimport { isValidNamedPackage } from './move-registry.js';\n\nconst TX_DIGEST_LENGTH = 32;\n\n/** Returns whether the tx digest is valid based on the serialization format */\nexport function isValidTransactionDigest(value: string): value is string {\n\ttry {\n\t\tconst buffer = fromBase58(value);\n\t\treturn buffer.length === TX_DIGEST_LENGTH;\n\t} catch {\n\t\treturn false;\n\t}\n}\n\n// TODO - can we automatically sync this with rust length definition?\n// Source of truth is\n// https://github.com/MystenLabs/sui/blob/acb2b97ae21f47600e05b0d28127d88d0725561d/crates/sui-types/src/base_types.rs#L67\n// which uses the Move account address length\n// https://github.com/move-language/move/blob/67ec40dc50c66c34fd73512fcc412f3b68d67235/language/move-core/types/src/account_address.rs#L23 .\n\nexport const SUI_ADDRESS_LENGTH = 32;\nexport function isValidSuiAddress(value: string): value is string {\n\treturn isHex(value) && getHexByteLength(value) === SUI_ADDRESS_LENGTH;\n}\n\nexport function isValidSuiObjectId(value: string): boolean {\n\treturn isValidSuiAddress(value);\n}\n\nexport type StructTag = {\n\taddress: string;\n\tmodule: string;\n\tname: string;\n\ttypeParams: (string | StructTag)[];\n};\n\nfunction parseTypeTag(type: string): string | StructTag {\n\tif (!type.includes('::')) return type;\n\n\treturn parseStructTag(type);\n}\n\nexport function parseStructTag(type: string): StructTag {\n\tconst parts = type.split('::');\n\n\tif (parts.length < 3) {\n\t\tthrow new Error(`Invalid struct tag: ${type}`);\n\t}\n\n\tconst [address, module] = parts;\n\tconst isMvrPackage = isValidNamedPackage(address);\n\n\tconst rest = type.slice(address.length + module.length + 4);\n\tconst name = rest.includes('<') ? rest.slice(0, rest.indexOf('<')) : rest;\n\tconst typeParams = rest.includes('<')\n\t\t? splitGenericParameters(rest.slice(rest.indexOf('<') + 1, rest.lastIndexOf('>'))).map(\n\t\t\t\t(typeParam) => parseTypeTag(typeParam.trim()),\n\t\t\t)\n\t\t: [];\n\n\treturn {\n\t\taddress: isMvrPackage ? address : normalizeSuiAddress(address),\n\t\tmodule,\n\t\tname,\n\t\ttypeParams,\n\t};\n}\n\nexport function normalizeStructTag(type: string | StructTag): string {\n\tconst { address, module, name, typeParams } =\n\t\ttypeof type === 'string' ? parseStructTag(type) : type;\n\n\tconst formattedTypeParams =\n\t\ttypeParams?.length > 0\n\t\t\t? `<${typeParams\n\t\t\t\t\t.map((typeParam) =>\n\t\t\t\t\t\ttypeof typeParam === 'string' ? typeParam : normalizeStructTag(typeParam),\n\t\t\t\t\t)\n\t\t\t\t\t.join(',')}>`\n\t\t\t: '';\n\n\treturn `${address}::${module}::${name}${formattedTypeParams}`;\n}\n\n/**\n * Perform the following operations:\n * 1. Make the address lower case\n * 2. Prepend `0x` if the string does not start with `0x`.\n * 3. Add more zeros if the length of the address(excluding `0x`) is less than `SUI_ADDRESS_LENGTH`\n *\n * WARNING: if the address value itself starts with `0x`, e.g., `0x0x`, the default behavior\n * is to treat the first `0x` not as part of the address. The default behavior can be overridden by\n * setting `forceAdd0x` to true\n *\n */\nexport function normalizeSuiAddress(value: string, forceAdd0x: boolean = false): string {\n\tlet address = value.toLowerCase();\n\tif (!forceAdd0x && address.startsWith('0x')) {\n\t\taddress = address.slice(2);\n\t}\n\treturn `0x${address.padStart(SUI_ADDRESS_LENGTH * 2, '0')}`;\n}\n\nexport function normalizeSuiObjectId(value: string, forceAdd0x: boolean = false): string {\n\treturn normalizeSuiAddress(value, forceAdd0x);\n}\n\nfunction isHex(value: string): boolean {\n\treturn /^(0x|0X)?[a-fA-F0-9]+$/.test(value) && value.length % 2 === 0;\n}\n\nfunction getHexByteLength(value: string): number {\n\treturn /^(0x|0X)/.test(value) ? (value.length - 2) / 2 : value.length / 2;\n}\n"],"mappings":";;;;AAOA,MAAM,mBAAmB;;AAGzB,SAAgB,yBAAyB,OAAgC;AACxE,KAAI;AAEH,SADe,WAAW,MAAM,CAClB,WAAW;SAClB;AACP,SAAO;;;AAUT,MAAa,qBAAqB;AAClC,SAAgB,kBAAkB,OAAgC;AACjE,QAAO,MAAM,MAAM,IAAI,iBAAiB,MAAM,KAAK;;AAGpD,SAAgB,mBAAmB,OAAwB;AAC1D,QAAO,kBAAkB,MAAM;;AAUhC,SAAS,aAAa,MAAkC;AACvD,KAAI,CAAC,KAAK,SAAS,KAAK,CAAE,QAAO;AAEjC,QAAO,eAAe,KAAK;;AAG5B,SAAgB,eAAe,MAAyB;CACvD,MAAM,QAAQ,KAAK,MAAM,KAAK;AAE9B,KAAI,MAAM,SAAS,EAClB,OAAM,IAAI,MAAM,uBAAuB,OAAO;CAG/C,MAAM,CAAC,SAAS,UAAU;CAC1B,MAAM,eAAe,oBAAoB,QAAQ;CAEjD,MAAM,OAAO,KAAK,MAAM,QAAQ,SAAS,OAAO,SAAS,EAAE;CAC3D,MAAM,OAAO,KAAK,SAAS,IAAI,GAAG,KAAK,MAAM,GAAG,KAAK,QAAQ,IAAI,CAAC,GAAG;CACrE,MAAM,aAAa,KAAK,SAAS,IAAI,GAClC,uBAAuB,KAAK,MAAM,KAAK,QAAQ,IAAI,GAAG,GAAG,KAAK,YAAY,IAAI,CAAC,CAAC,CAAC,KAChF,cAAc,aAAa,UAAU,MAAM,CAAC,CAC7C,GACA,EAAE;AAEL,QAAO;EACN,SAAS,eAAe,UAAU,oBAAoB,QAAQ;EAC9D;EACA;EACA;EACA;;AAGF,SAAgB,mBAAmB,MAAkC;CACpE,MAAM,EAAE,SAAS,QAAQ,MAAM,eAC9B,OAAO,SAAS,WAAW,eAAe,KAAK,GAAG;AAWnD,QAAO,GAAG,QAAQ,IAAI,OAAO,IAAI,OARhC,YAAY,SAAS,IAClB,IAAI,WACH,KAAK,cACL,OAAO,cAAc,WAAW,YAAY,mBAAmB,UAAU,CACzE,CACA,KAAK,IAAI,CAAC,KACX;;;;;;;;;;;;;AAgBL,SAAgB,oBAAoB,OAAe,aAAsB,OAAe;CACvF,IAAI,UAAU,MAAM,aAAa;AACjC,KAAI,CAAC,cAAc,QAAQ,WAAW,KAAK,CAC1C,WAAU,QAAQ,MAAM,EAAE;AAE3B,QAAO,KAAK,QAAQ,SAAS,qBAAqB,GAAG,IAAI;;AAG1D,SAAgB,qBAAqB,OAAe,aAAsB,OAAe;AACxF,QAAO,oBAAoB,OAAO,WAAW;;AAG9C,SAAS,MAAM,OAAwB;AACtC,QAAO,yBAAyB,KAAK,MAAM,IAAI,MAAM,SAAS,MAAM;;AAGrE,SAAS,iBAAiB,OAAuB;AAChD,QAAO,WAAW,KAAK,MAAM,IAAI,MAAM,SAAS,KAAK,IAAI,MAAM,SAAS"}