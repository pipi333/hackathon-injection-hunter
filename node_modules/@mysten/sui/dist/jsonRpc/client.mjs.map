{"version":3,"file":"client.mjs","names":[],"sources":["../../src/jsonRpc/client.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\nimport { fromBase58, toBase64, toHex } from '@mysten/bcs';\n\nimport type { Signer } from '../cryptography/index.js';\nimport { BaseClient } from '../client/client.js';\nimport type { SuiClientTypes } from '../client/types.js';\nimport type { Transaction } from '../transactions/Transaction.js';\nimport { isTransaction } from '../transactions/Transaction.js';\nimport {\n\tisValidSuiAddress,\n\tisValidSuiObjectId,\n\tisValidTransactionDigest,\n\tnormalizeSuiAddress,\n\tnormalizeSuiObjectId,\n} from '../utils/sui-types.js';\nimport { normalizeSuiNSName } from '../utils/suins.js';\nimport { JsonRpcHTTPTransport } from './http-transport.js';\nimport type { JsonRpcTransport } from './http-transport.js';\nimport type {\n\tAddressMetrics,\n\tAllEpochsAddressMetrics,\n\tCheckpoint,\n\tCheckpointPage,\n\tCoinBalance,\n\tCoinMetadata,\n\tCoinSupply,\n\tCommitteeInfo,\n\tDelegatedStake,\n\tDevInspectResults,\n\tDevInspectTransactionBlockParams,\n\tDryRunTransactionBlockParams,\n\tDryRunTransactionBlockResponse,\n\tDynamicFieldPage,\n\tEpochInfo,\n\tEpochMetricsPage,\n\tEpochPage,\n\tExecuteTransactionBlockParams,\n\tGetAllBalancesParams,\n\tGetAllCoinsParams,\n\tGetBalanceParams,\n\tGetCheckpointParams,\n\tGetCheckpointsParams,\n\tGetCoinMetadataParams,\n\tGetCoinsParams,\n\tGetCommitteeInfoParams,\n\tGetDynamicFieldObjectParams,\n\tGetDynamicFieldsParams,\n\tGetLatestCheckpointSequenceNumberParams,\n\tGetLatestSuiSystemStateParams,\n\tGetMoveFunctionArgTypesParams,\n\tGetNormalizedMoveFunctionParams,\n\tGetNormalizedMoveModuleParams,\n\tGetNormalizedMoveModulesByPackageParams,\n\tGetNormalizedMoveStructParams,\n\tGetObjectParams,\n\tGetOwnedObjectsParams,\n\tGetProtocolConfigParams,\n\tGetReferenceGasPriceParams,\n\tGetStakesByIdsParams,\n\tGetStakesParams,\n\tGetTotalSupplyParams,\n\tGetTransactionBlockParams,\n\tMoveCallMetrics,\n\tMultiGetObjectsParams,\n\tMultiGetTransactionBlocksParams,\n\tNetworkMetrics,\n\tObjectRead,\n\tOrder,\n\tPaginatedCoins,\n\tPaginatedEvents,\n\tPaginatedObjectsResponse,\n\tPaginatedTransactionResponse,\n\tProtocolConfig,\n\tQueryEventsParams,\n\tQueryTransactionBlocksParams,\n\tResolvedNameServiceNames,\n\tResolveNameServiceAddressParams,\n\tResolveNameServiceNamesParams,\n\tSuiMoveFunctionArgType,\n\tSuiMoveNormalizedFunction,\n\tSuiMoveNormalizedModule,\n\tSuiMoveNormalizedModules,\n\tSuiMoveNormalizedStruct,\n\tSuiObjectResponse,\n\tSuiObjectResponseQuery,\n\tSuiSystemStateSummary,\n\tSuiTransactionBlockResponse,\n\tSuiTransactionBlockResponseQuery,\n\tTryGetPastObjectParams,\n\tValidatorsApy,\n\tVerifyZkLoginSignatureParams,\n\tZkLoginVerifyResult,\n} from './types/index.js';\nimport { isValidNamedPackage } from '../utils/move-registry.js';\nimport { hasMvrName } from '../client/mvr.js';\nimport { JSONRpcCoreClient } from './core.js';\n\nexport interface PaginationArguments<Cursor> {\n\t/** Optional paging cursor */\n\tcursor?: Cursor;\n\t/** Maximum item returned per page */\n\tlimit?: number | null;\n}\n\nexport interface OrderArguments {\n\torder?: Order | null;\n}\n\n/**\n * Configuration options for the SuiJsonRpcClient\n * You must provide either a `url` or a `transport`\n */\nexport type SuiJsonRpcClientOptions = NetworkOrTransport & {\n\tnetwork: SuiClientTypes.Network;\n\tmvr?: SuiClientTypes.MvrOptions;\n};\n\ntype NetworkOrTransport =\n\t| {\n\t\t\turl: string;\n\t\t\ttransport?: never;\n\t  }\n\t| {\n\t\t\ttransport: JsonRpcTransport;\n\t\t\turl?: never;\n\t  };\n\nconst SUI_CLIENT_BRAND = Symbol.for('@mysten/SuiJsonRpcClient') as never;\n\n// Magic number used to identify fake address balance coins (last 20 bytes of the digest)\n// See: sui/crates/sui-types/src/coin_reservation.rs\nconst COIN_RESERVATION_MAGIC = new Uint8Array([\n\t0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac,\n\t0xac, 0xac, 0xac, 0xac,\n]);\n\n/**\n * Checks if a digest indicates a fake address balance coin.\n * These \"coins\" are created by the JSON RPC to represent address balances\n * and should be filtered out from coin listings.\n */\nfunction isCoinReservationDigest(digestBase58: string): boolean {\n\tconst digestBytes = fromBase58(digestBase58);\n\t// Check if the last 20 bytes match the magic number\n\tconst last20Bytes = digestBytes.slice(12, 32);\n\treturn last20Bytes.every((byte, i) => byte === COIN_RESERVATION_MAGIC[i]);\n}\n\nexport function isSuiJsonRpcClient(client: unknown): client is SuiJsonRpcClient {\n\treturn (\n\t\ttypeof client === 'object' && client !== null && (client as any)[SUI_CLIENT_BRAND] === true\n\t);\n}\n\nexport class SuiJsonRpcClient extends BaseClient {\n\tcore: JSONRpcCoreClient;\n\tjsonRpc = this;\n\tprotected transport: JsonRpcTransport;\n\n\tget [SUI_CLIENT_BRAND]() {\n\t\treturn true;\n\t}\n\n\t/**\n\t * Establish a connection to a Sui RPC endpoint\n\t *\n\t * @param options configuration options for the API Client\n\t */\n\tconstructor(options: SuiJsonRpcClientOptions) {\n\t\tsuper({ network: options.network });\n\t\tthis.transport = options.transport ?? new JsonRpcHTTPTransport({ url: options.url });\n\t\tthis.core = new JSONRpcCoreClient({\n\t\t\tjsonRpcClient: this,\n\t\t\tmvr: options.mvr,\n\t\t});\n\t}\n\n\tasync getRpcApiVersion({ signal }: { signal?: AbortSignal } = {}): Promise<string | undefined> {\n\t\tconst resp = await this.transport.request<{ info: { version: string } }>({\n\t\t\tmethod: 'rpc.discover',\n\t\t\tparams: [],\n\t\t\tsignal,\n\t\t});\n\n\t\treturn resp.info.version;\n\t}\n\n\t/**\n\t * Get all Coin<`coin_type`> objects owned by an address.\n\t */\n\tasync getCoins({\n\t\tcoinType,\n\t\towner,\n\t\tcursor,\n\t\tlimit,\n\t\tsignal,\n\t}: GetCoinsParams): Promise<PaginatedCoins> {\n\t\tif (!owner || !isValidSuiAddress(normalizeSuiAddress(owner))) {\n\t\t\tthrow new Error('Invalid Sui address');\n\t\t}\n\n\t\tif (coinType && hasMvrName(coinType)) {\n\t\t\tcoinType = (\n\t\t\t\tawait this.core.mvr.resolveType({\n\t\t\t\t\ttype: coinType,\n\t\t\t\t})\n\t\t\t).type;\n\t\t}\n\n\t\tconst result: PaginatedCoins = await this.transport.request({\n\t\t\tmethod: 'suix_getCoins',\n\t\t\tparams: [owner, coinType, cursor, limit],\n\t\t\tsignal: signal,\n\t\t});\n\n\t\treturn {\n\t\t\t...result,\n\t\t\tdata: result.data.filter((coin) => !isCoinReservationDigest(coin.digest)),\n\t\t};\n\t}\n\n\t/**\n\t * Get all Coin objects owned by an address.\n\t */\n\tasync getAllCoins(input: GetAllCoinsParams): Promise<PaginatedCoins> {\n\t\tif (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {\n\t\t\tthrow new Error('Invalid Sui address');\n\t\t}\n\n\t\tconst result: PaginatedCoins = await this.transport.request({\n\t\t\tmethod: 'suix_getAllCoins',\n\t\t\tparams: [input.owner, input.cursor, input.limit],\n\t\t\tsignal: input.signal,\n\t\t});\n\n\t\treturn {\n\t\t\t...result,\n\t\t\tdata: result.data.filter((coin) => !isCoinReservationDigest(coin.digest)),\n\t\t};\n\t}\n\n\t/**\n\t * Get the total coin balance for one coin type, owned by the address owner.\n\t */\n\tasync getBalance({ owner, coinType, signal }: GetBalanceParams): Promise<CoinBalance> {\n\t\tif (!owner || !isValidSuiAddress(normalizeSuiAddress(owner))) {\n\t\t\tthrow new Error('Invalid Sui address');\n\t\t}\n\n\t\tif (coinType && hasMvrName(coinType)) {\n\t\t\tcoinType = (\n\t\t\t\tawait this.core.mvr.resolveType({\n\t\t\t\t\ttype: coinType,\n\t\t\t\t})\n\t\t\t).type;\n\t\t}\n\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'suix_getBalance',\n\t\t\tparams: [owner, coinType],\n\t\t\tsignal: signal,\n\t\t});\n\t}\n\n\t/**\n\t * Get the total coin balance for all coin types, owned by the address owner.\n\t */\n\tasync getAllBalances(input: GetAllBalancesParams): Promise<CoinBalance[]> {\n\t\tif (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {\n\t\t\tthrow new Error('Invalid Sui address');\n\t\t}\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'suix_getAllBalances',\n\t\t\tparams: [input.owner],\n\t\t\tsignal: input.signal,\n\t\t});\n\t}\n\n\t/**\n\t * Fetch CoinMetadata for a given coin type\n\t */\n\tasync getCoinMetadata({ coinType, signal }: GetCoinMetadataParams): Promise<CoinMetadata | null> {\n\t\tif (coinType && hasMvrName(coinType)) {\n\t\t\tcoinType = (\n\t\t\t\tawait this.core.mvr.resolveType({\n\t\t\t\t\ttype: coinType,\n\t\t\t\t})\n\t\t\t).type;\n\t\t}\n\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'suix_getCoinMetadata',\n\t\t\tparams: [coinType],\n\t\t\tsignal: signal,\n\t\t});\n\t}\n\n\t/**\n\t *  Fetch total supply for a coin\n\t */\n\tasync getTotalSupply({ coinType, signal }: GetTotalSupplyParams): Promise<CoinSupply> {\n\t\tif (coinType && hasMvrName(coinType)) {\n\t\t\tcoinType = (\n\t\t\t\tawait this.core.mvr.resolveType({\n\t\t\t\t\ttype: coinType,\n\t\t\t\t})\n\t\t\t).type;\n\t\t}\n\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'suix_getTotalSupply',\n\t\t\tparams: [coinType],\n\t\t\tsignal: signal,\n\t\t});\n\t}\n\n\t/**\n\t * Invoke any RPC method\n\t * @param method the method to be invoked\n\t * @param args the arguments to be passed to the RPC request\n\t */\n\tasync call<T = unknown>(\n\t\tmethod: string,\n\t\tparams: unknown[],\n\t\t{ signal }: { signal?: AbortSignal } = {},\n\t): Promise<T> {\n\t\treturn await this.transport.request({ method, params, signal });\n\t}\n\n\t/**\n\t * Get Move function argument types like read, write and full access\n\t */\n\tasync getMoveFunctionArgTypes({\n\t\tpackage: pkg,\n\t\tmodule,\n\t\tfunction: fn,\n\t\tsignal,\n\t}: GetMoveFunctionArgTypesParams): Promise<SuiMoveFunctionArgType[]> {\n\t\tif (pkg && isValidNamedPackage(pkg)) {\n\t\t\tpkg = (\n\t\t\t\tawait this.core.mvr.resolvePackage({\n\t\t\t\t\tpackage: pkg,\n\t\t\t\t})\n\t\t\t).package;\n\t\t}\n\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'sui_getMoveFunctionArgTypes',\n\t\t\tparams: [pkg, module, fn],\n\t\t\tsignal: signal,\n\t\t});\n\t}\n\n\t/**\n\t * Get a map from module name to\n\t * structured representations of Move modules\n\t */\n\tasync getNormalizedMoveModulesByPackage({\n\t\tpackage: pkg,\n\t\tsignal,\n\t}: GetNormalizedMoveModulesByPackageParams): Promise<SuiMoveNormalizedModules> {\n\t\tif (pkg && isValidNamedPackage(pkg)) {\n\t\t\tpkg = (\n\t\t\t\tawait this.core.mvr.resolvePackage({\n\t\t\t\t\tpackage: pkg,\n\t\t\t\t})\n\t\t\t).package;\n\t\t}\n\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'sui_getNormalizedMoveModulesByPackage',\n\t\t\tparams: [pkg],\n\t\t\tsignal: signal,\n\t\t});\n\t}\n\n\t/**\n\t * Get a structured representation of Move module\n\t */\n\tasync getNormalizedMoveModule({\n\t\tpackage: pkg,\n\t\tmodule,\n\t\tsignal,\n\t}: GetNormalizedMoveModuleParams): Promise<SuiMoveNormalizedModule> {\n\t\tif (pkg && isValidNamedPackage(pkg)) {\n\t\t\tpkg = (\n\t\t\t\tawait this.core.mvr.resolvePackage({\n\t\t\t\t\tpackage: pkg,\n\t\t\t\t})\n\t\t\t).package;\n\t\t}\n\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'sui_getNormalizedMoveModule',\n\t\t\tparams: [pkg, module],\n\t\t\tsignal: signal,\n\t\t});\n\t}\n\n\t/**\n\t * Get a structured representation of Move function\n\t */\n\tasync getNormalizedMoveFunction({\n\t\tpackage: pkg,\n\t\tmodule,\n\t\tfunction: fn,\n\t\tsignal,\n\t}: GetNormalizedMoveFunctionParams): Promise<SuiMoveNormalizedFunction> {\n\t\tif (pkg && isValidNamedPackage(pkg)) {\n\t\t\tpkg = (\n\t\t\t\tawait this.core.mvr.resolvePackage({\n\t\t\t\t\tpackage: pkg,\n\t\t\t\t})\n\t\t\t).package;\n\t\t}\n\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'sui_getNormalizedMoveFunction',\n\t\t\tparams: [pkg, module, fn],\n\t\t\tsignal: signal,\n\t\t});\n\t}\n\n\t/**\n\t * Get a structured representation of Move struct\n\t */\n\tasync getNormalizedMoveStruct({\n\t\tpackage: pkg,\n\t\tmodule,\n\t\tstruct,\n\t\tsignal,\n\t}: GetNormalizedMoveStructParams): Promise<SuiMoveNormalizedStruct> {\n\t\tif (pkg && isValidNamedPackage(pkg)) {\n\t\t\tpkg = (\n\t\t\t\tawait this.core.mvr.resolvePackage({\n\t\t\t\t\tpackage: pkg,\n\t\t\t\t})\n\t\t\t).package;\n\t\t}\n\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'sui_getNormalizedMoveStruct',\n\t\t\tparams: [pkg, module, struct],\n\t\t\tsignal: signal,\n\t\t});\n\t}\n\n\t/**\n\t * Get all objects owned by an address\n\t */\n\tasync getOwnedObjects(input: GetOwnedObjectsParams): Promise<PaginatedObjectsResponse> {\n\t\tif (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {\n\t\t\tthrow new Error('Invalid Sui address');\n\t\t}\n\n\t\tconst filter = input.filter\n\t\t\t? {\n\t\t\t\t\t...input.filter,\n\t\t\t\t}\n\t\t\t: undefined;\n\n\t\tif (filter && 'MoveModule' in filter && isValidNamedPackage(filter.MoveModule.package)) {\n\t\t\tfilter.MoveModule = {\n\t\t\t\tmodule: filter.MoveModule.module,\n\t\t\t\tpackage: (\n\t\t\t\t\tawait this.core.mvr.resolvePackage({\n\t\t\t\t\t\tpackage: filter.MoveModule.package,\n\t\t\t\t\t})\n\t\t\t\t).package,\n\t\t\t};\n\t\t} else if (filter && 'StructType' in filter && hasMvrName(filter.StructType)) {\n\t\t\tfilter.StructType = (\n\t\t\t\tawait this.core.mvr.resolveType({\n\t\t\t\t\ttype: filter.StructType,\n\t\t\t\t})\n\t\t\t).type;\n\t\t}\n\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'suix_getOwnedObjects',\n\t\t\tparams: [\n\t\t\t\tinput.owner,\n\t\t\t\t{\n\t\t\t\t\tfilter,\n\t\t\t\t\toptions: input.options,\n\t\t\t\t} as SuiObjectResponseQuery,\n\t\t\t\tinput.cursor,\n\t\t\t\tinput.limit,\n\t\t\t],\n\t\t\tsignal: input.signal,\n\t\t});\n\t}\n\n\t/**\n\t * Get details about an object\n\t */\n\tasync getObject(input: GetObjectParams): Promise<SuiObjectResponse> {\n\t\tif (!input.id || !isValidSuiObjectId(normalizeSuiObjectId(input.id))) {\n\t\t\tthrow new Error('Invalid Sui Object id');\n\t\t}\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'sui_getObject',\n\t\t\tparams: [input.id, input.options],\n\t\t\tsignal: input.signal,\n\t\t});\n\t}\n\n\tasync tryGetPastObject(input: TryGetPastObjectParams): Promise<ObjectRead> {\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'sui_tryGetPastObject',\n\t\t\tparams: [input.id, input.version, input.options],\n\t\t\tsignal: input.signal,\n\t\t});\n\t}\n\n\t/**\n\t * Batch get details about a list of objects. If any of the object ids are duplicates the call will fail\n\t */\n\tasync multiGetObjects(input: MultiGetObjectsParams): Promise<SuiObjectResponse[]> {\n\t\tinput.ids.forEach((id) => {\n\t\t\tif (!id || !isValidSuiObjectId(normalizeSuiObjectId(id))) {\n\t\t\t\tthrow new Error(`Invalid Sui Object id ${id}`);\n\t\t\t}\n\t\t});\n\t\tconst hasDuplicates = input.ids.length !== new Set(input.ids).size;\n\t\tif (hasDuplicates) {\n\t\t\tthrow new Error(`Duplicate object ids in batch call ${input.ids}`);\n\t\t}\n\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'sui_multiGetObjects',\n\t\t\tparams: [input.ids, input.options],\n\t\t\tsignal: input.signal,\n\t\t});\n\t}\n\n\t/**\n\t * Get transaction blocks for a given query criteria\n\t */\n\tasync queryTransactionBlocks({\n\t\tfilter,\n\t\toptions,\n\t\tcursor,\n\t\tlimit,\n\t\torder,\n\t\tsignal,\n\t}: QueryTransactionBlocksParams): Promise<PaginatedTransactionResponse> {\n\t\tif (filter && 'MoveFunction' in filter && isValidNamedPackage(filter.MoveFunction.package)) {\n\t\t\tfilter = {\n\t\t\t\t...filter,\n\t\t\t\tMoveFunction: {\n\t\t\t\t\tpackage: (\n\t\t\t\t\t\tawait this.core.mvr.resolvePackage({\n\t\t\t\t\t\t\tpackage: filter.MoveFunction.package,\n\t\t\t\t\t\t})\n\t\t\t\t\t).package,\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'suix_queryTransactionBlocks',\n\t\t\tparams: [\n\t\t\t\t{\n\t\t\t\t\tfilter,\n\t\t\t\t\toptions,\n\t\t\t\t} as SuiTransactionBlockResponseQuery,\n\t\t\t\tcursor,\n\t\t\t\tlimit,\n\t\t\t\t(order || 'descending') === 'descending',\n\t\t\t],\n\t\t\tsignal,\n\t\t});\n\t}\n\n\tasync getTransactionBlock(\n\t\tinput: GetTransactionBlockParams,\n\t): Promise<SuiTransactionBlockResponse> {\n\t\tif (!isValidTransactionDigest(input.digest)) {\n\t\t\tthrow new Error('Invalid Transaction digest');\n\t\t}\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'sui_getTransactionBlock',\n\t\t\tparams: [input.digest, input.options],\n\t\t\tsignal: input.signal,\n\t\t});\n\t}\n\n\tasync multiGetTransactionBlocks(\n\t\tinput: MultiGetTransactionBlocksParams,\n\t): Promise<SuiTransactionBlockResponse[]> {\n\t\tinput.digests.forEach((d) => {\n\t\t\tif (!isValidTransactionDigest(d)) {\n\t\t\t\tthrow new Error(`Invalid Transaction digest ${d}`);\n\t\t\t}\n\t\t});\n\n\t\tconst hasDuplicates = input.digests.length !== new Set(input.digests).size;\n\t\tif (hasDuplicates) {\n\t\t\tthrow new Error(`Duplicate digests in batch call ${input.digests}`);\n\t\t}\n\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'sui_multiGetTransactionBlocks',\n\t\t\tparams: [input.digests, input.options],\n\t\t\tsignal: input.signal,\n\t\t});\n\t}\n\n\tasync executeTransactionBlock({\n\t\ttransactionBlock,\n\t\tsignature,\n\t\toptions,\n\t\tsignal,\n\t}: ExecuteTransactionBlockParams): Promise<SuiTransactionBlockResponse> {\n\t\tconst result: SuiTransactionBlockResponse = await this.transport.request({\n\t\t\tmethod: 'sui_executeTransactionBlock',\n\t\t\tparams: [\n\t\t\t\ttypeof transactionBlock === 'string' ? transactionBlock : toBase64(transactionBlock),\n\t\t\t\tArray.isArray(signature) ? signature : [signature],\n\t\t\t\toptions,\n\t\t\t],\n\t\t\tsignal,\n\t\t});\n\n\t\treturn result;\n\t}\n\n\tasync signAndExecuteTransaction({\n\t\ttransaction,\n\t\tsigner,\n\t\t...input\n\t}: {\n\t\ttransaction: Uint8Array | Transaction;\n\t\tsigner: Signer;\n\t} & Omit<\n\t\tExecuteTransactionBlockParams,\n\t\t'transactionBlock' | 'signature'\n\t>): Promise<SuiTransactionBlockResponse> {\n\t\tlet transactionBytes;\n\n\t\tif (transaction instanceof Uint8Array) {\n\t\t\ttransactionBytes = transaction;\n\t\t} else {\n\t\t\ttransaction.setSenderIfNotSet(signer.toSuiAddress());\n\t\t\ttransactionBytes = await transaction.build({ client: this });\n\t\t}\n\n\t\tconst { signature, bytes } = await signer.signTransaction(transactionBytes);\n\n\t\treturn this.executeTransactionBlock({\n\t\t\ttransactionBlock: bytes,\n\t\t\tsignature,\n\t\t\t...input,\n\t\t});\n\t}\n\n\t/**\n\t * Get total number of transactions\n\t */\n\n\tasync getTotalTransactionBlocks({ signal }: { signal?: AbortSignal } = {}): Promise<bigint> {\n\t\tconst resp = await this.transport.request<string>({\n\t\t\tmethod: 'sui_getTotalTransactionBlocks',\n\t\t\tparams: [],\n\t\t\tsignal,\n\t\t});\n\t\treturn BigInt(resp);\n\t}\n\n\t/**\n\t * Getting the reference gas price for the network\n\t */\n\tasync getReferenceGasPrice({ signal }: GetReferenceGasPriceParams = {}): Promise<bigint> {\n\t\tconst resp = await this.transport.request<string>({\n\t\t\tmethod: 'suix_getReferenceGasPrice',\n\t\t\tparams: [],\n\t\t\tsignal,\n\t\t});\n\t\treturn BigInt(resp);\n\t}\n\n\t/**\n\t * Return the delegated stakes for an address\n\t */\n\tasync getStakes(input: GetStakesParams): Promise<DelegatedStake[]> {\n\t\tif (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {\n\t\t\tthrow new Error('Invalid Sui address');\n\t\t}\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'suix_getStakes',\n\t\t\tparams: [input.owner],\n\t\t\tsignal: input.signal,\n\t\t});\n\t}\n\n\t/**\n\t * Return the delegated stakes queried by id.\n\t */\n\tasync getStakesByIds(input: GetStakesByIdsParams): Promise<DelegatedStake[]> {\n\t\tinput.stakedSuiIds.forEach((id) => {\n\t\t\tif (!id || !isValidSuiObjectId(normalizeSuiObjectId(id))) {\n\t\t\t\tthrow new Error(`Invalid Sui Stake id ${id}`);\n\t\t\t}\n\t\t});\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'suix_getStakesByIds',\n\t\t\tparams: [input.stakedSuiIds],\n\t\t\tsignal: input.signal,\n\t\t});\n\t}\n\n\t/**\n\t * Return the latest system state content.\n\t */\n\tasync getLatestSuiSystemState({\n\t\tsignal,\n\t}: GetLatestSuiSystemStateParams = {}): Promise<SuiSystemStateSummary> {\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'suix_getLatestSuiSystemState',\n\t\t\tparams: [],\n\t\t\tsignal,\n\t\t});\n\t}\n\n\t/**\n\t * Get events for a given query criteria\n\t */\n\tasync queryEvents({\n\t\tquery,\n\t\tcursor,\n\t\tlimit,\n\t\torder,\n\t\tsignal,\n\t}: QueryEventsParams): Promise<PaginatedEvents> {\n\t\tif (query && 'MoveEventType' in query && hasMvrName(query.MoveEventType)) {\n\t\t\tquery = {\n\t\t\t\t...query,\n\t\t\t\tMoveEventType: (\n\t\t\t\t\tawait this.core.mvr.resolveType({\n\t\t\t\t\t\ttype: query.MoveEventType,\n\t\t\t\t\t})\n\t\t\t\t).type,\n\t\t\t};\n\t\t}\n\n\t\tif (query && 'MoveEventModule' in query && isValidNamedPackage(query.MoveEventModule.package)) {\n\t\t\tquery = {\n\t\t\t\t...query,\n\t\t\t\tMoveEventModule: {\n\t\t\t\t\tmodule: query.MoveEventModule.module,\n\t\t\t\t\tpackage: (\n\t\t\t\t\t\tawait this.core.mvr.resolvePackage({\n\t\t\t\t\t\t\tpackage: query.MoveEventModule.package,\n\t\t\t\t\t\t})\n\t\t\t\t\t).package,\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\n\t\tif ('MoveModule' in query && isValidNamedPackage(query.MoveModule.package)) {\n\t\t\tquery = {\n\t\t\t\t...query,\n\t\t\t\tMoveModule: {\n\t\t\t\t\tmodule: query.MoveModule.module,\n\t\t\t\t\tpackage: (\n\t\t\t\t\t\tawait this.core.mvr.resolvePackage({\n\t\t\t\t\t\t\tpackage: query.MoveModule.package,\n\t\t\t\t\t\t})\n\t\t\t\t\t).package,\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'suix_queryEvents',\n\t\t\tparams: [query, cursor, limit, (order || 'descending') === 'descending'],\n\t\t\tsignal,\n\t\t});\n\t}\n\n\t/**\n\t * Runs the transaction block in dev-inspect mode. Which allows for nearly any\n\t * transaction (or Move call) with any arguments. Detailed results are\n\t * provided, including both the transaction effects and any return values.\n\t */\n\tasync devInspectTransactionBlock(\n\t\tinput: DevInspectTransactionBlockParams,\n\t): Promise<DevInspectResults> {\n\t\tlet devInspectTxBytes;\n\t\tif (isTransaction(input.transactionBlock)) {\n\t\t\tinput.transactionBlock.setSenderIfNotSet(input.sender);\n\t\t\tdevInspectTxBytes = toBase64(\n\t\t\t\tawait input.transactionBlock.build({\n\t\t\t\t\tclient: this,\n\t\t\t\t\tonlyTransactionKind: true,\n\t\t\t\t}),\n\t\t\t);\n\t\t} else if (typeof input.transactionBlock === 'string') {\n\t\t\tdevInspectTxBytes = input.transactionBlock;\n\t\t} else if (input.transactionBlock instanceof Uint8Array) {\n\t\t\tdevInspectTxBytes = toBase64(input.transactionBlock);\n\t\t} else {\n\t\t\tthrow new Error('Unknown transaction block format.');\n\t\t}\n\n\t\tinput.signal?.throwIfAborted();\n\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'sui_devInspectTransactionBlock',\n\t\t\tparams: [input.sender, devInspectTxBytes, input.gasPrice?.toString(), input.epoch],\n\t\t\tsignal: input.signal,\n\t\t});\n\t}\n\n\t/**\n\t * Dry run a transaction block and return the result.\n\t */\n\tasync dryRunTransactionBlock(\n\t\tinput: DryRunTransactionBlockParams,\n\t): Promise<DryRunTransactionBlockResponse> {\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'sui_dryRunTransactionBlock',\n\t\t\tparams: [\n\t\t\t\ttypeof input.transactionBlock === 'string'\n\t\t\t\t\t? input.transactionBlock\n\t\t\t\t\t: toBase64(input.transactionBlock),\n\t\t\t],\n\t\t});\n\t}\n\n\t/**\n\t * Return the list of dynamic field objects owned by an object\n\t */\n\tasync getDynamicFields(input: GetDynamicFieldsParams): Promise<DynamicFieldPage> {\n\t\tif (!input.parentId || !isValidSuiObjectId(normalizeSuiObjectId(input.parentId))) {\n\t\t\tthrow new Error('Invalid Sui Object id');\n\t\t}\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'suix_getDynamicFields',\n\t\t\tparams: [input.parentId, input.cursor, input.limit],\n\t\t\tsignal: input.signal,\n\t\t});\n\t}\n\n\t/**\n\t * Return the dynamic field object information for a specified object\n\t */\n\tasync getDynamicFieldObject(input: GetDynamicFieldObjectParams): Promise<SuiObjectResponse> {\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'suix_getDynamicFieldObject',\n\t\t\tparams: [input.parentId, input.name],\n\t\t\tsignal: input.signal,\n\t\t});\n\t}\n\n\t/**\n\t * Get the sequence number of the latest checkpoint that has been executed\n\t */\n\tasync getLatestCheckpointSequenceNumber({\n\t\tsignal,\n\t}: GetLatestCheckpointSequenceNumberParams = {}): Promise<string> {\n\t\tconst resp = await this.transport.request({\n\t\t\tmethod: 'sui_getLatestCheckpointSequenceNumber',\n\t\t\tparams: [],\n\t\t\tsignal,\n\t\t});\n\t\treturn String(resp);\n\t}\n\n\t/**\n\t * Returns information about a given checkpoint\n\t */\n\tasync getCheckpoint(input: GetCheckpointParams): Promise<Checkpoint> {\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'sui_getCheckpoint',\n\t\t\tparams: [input.id],\n\t\t\tsignal: input.signal,\n\t\t});\n\t}\n\n\t/**\n\t * Returns historical checkpoints paginated\n\t */\n\tasync getCheckpoints(\n\t\tinput: PaginationArguments<CheckpointPage['nextCursor']> & GetCheckpointsParams,\n\t): Promise<CheckpointPage> {\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'sui_getCheckpoints',\n\t\t\tparams: [input.cursor, input?.limit, input.descendingOrder],\n\t\t\tsignal: input.signal,\n\t\t});\n\t}\n\n\t/**\n\t * Return the committee information for the asked epoch\n\t */\n\tasync getCommitteeInfo(input?: GetCommitteeInfoParams): Promise<CommitteeInfo> {\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'suix_getCommitteeInfo',\n\t\t\tparams: [input?.epoch],\n\t\t\tsignal: input?.signal,\n\t\t});\n\t}\n\n\tasync getNetworkMetrics({ signal }: { signal?: AbortSignal } = {}): Promise<NetworkMetrics> {\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'suix_getNetworkMetrics',\n\t\t\tparams: [],\n\t\t\tsignal,\n\t\t});\n\t}\n\n\tasync getAddressMetrics({ signal }: { signal?: AbortSignal } = {}): Promise<AddressMetrics> {\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'suix_getLatestAddressMetrics',\n\t\t\tparams: [],\n\t\t\tsignal,\n\t\t});\n\t}\n\n\tasync getEpochMetrics(\n\t\tinput?: {\n\t\t\tdescendingOrder?: boolean;\n\t\t\tsignal?: AbortSignal;\n\t\t} & PaginationArguments<EpochMetricsPage['nextCursor']>,\n\t): Promise<EpochMetricsPage> {\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'suix_getEpochMetrics',\n\t\t\tparams: [input?.cursor, input?.limit, input?.descendingOrder],\n\t\t\tsignal: input?.signal,\n\t\t});\n\t}\n\n\tasync getAllEpochAddressMetrics(input?: {\n\t\tdescendingOrder?: boolean;\n\t\tsignal?: AbortSignal;\n\t}): Promise<AllEpochsAddressMetrics> {\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'suix_getAllEpochAddressMetrics',\n\t\t\tparams: [input?.descendingOrder],\n\t\t\tsignal: input?.signal,\n\t\t});\n\t}\n\n\t/**\n\t * Return the committee information for the asked epoch\n\t */\n\tasync getEpochs(\n\t\tinput?: {\n\t\t\tdescendingOrder?: boolean;\n\t\t\tsignal?: AbortSignal;\n\t\t} & PaginationArguments<EpochPage['nextCursor']>,\n\t): Promise<EpochPage> {\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'suix_getEpochs',\n\t\t\tparams: [input?.cursor, input?.limit, input?.descendingOrder],\n\t\t\tsignal: input?.signal,\n\t\t});\n\t}\n\n\t/**\n\t * Returns list of top move calls by usage\n\t */\n\tasync getMoveCallMetrics({ signal }: { signal?: AbortSignal } = {}): Promise<MoveCallMetrics> {\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'suix_getMoveCallMetrics',\n\t\t\tparams: [],\n\t\t\tsignal,\n\t\t});\n\t}\n\n\t/**\n\t * Return the committee information for the asked epoch\n\t */\n\tasync getCurrentEpoch({ signal }: { signal?: AbortSignal } = {}): Promise<EpochInfo> {\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'suix_getCurrentEpoch',\n\t\t\tparams: [],\n\t\t\tsignal,\n\t\t});\n\t}\n\n\t/**\n\t * Return the Validators APYs\n\t */\n\tasync getValidatorsApy({ signal }: { signal?: AbortSignal } = {}): Promise<ValidatorsApy> {\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'suix_getValidatorsApy',\n\t\t\tparams: [],\n\t\t\tsignal,\n\t\t});\n\t}\n\n\t// TODO: Migrate this to `sui_getChainIdentifier` once it is widely available.\n\tasync getChainIdentifier({ signal }: { signal?: AbortSignal } = {}): Promise<string> {\n\t\tconst checkpoint = await this.getCheckpoint({ id: '0', signal });\n\t\tconst bytes = fromBase58(checkpoint.digest);\n\t\treturn toHex(bytes.slice(0, 4));\n\t}\n\n\tasync resolveNameServiceAddress(input: ResolveNameServiceAddressParams): Promise<string | null> {\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'suix_resolveNameServiceAddress',\n\t\t\tparams: [input.name],\n\t\t\tsignal: input.signal,\n\t\t});\n\t}\n\n\tasync resolveNameServiceNames({\n\t\tformat = 'dot',\n\t\t...input\n\t}: ResolveNameServiceNamesParams & {\n\t\tformat?: 'at' | 'dot';\n\t}): Promise<ResolvedNameServiceNames> {\n\t\tconst { nextCursor, hasNextPage, data }: ResolvedNameServiceNames =\n\t\t\tawait this.transport.request({\n\t\t\t\tmethod: 'suix_resolveNameServiceNames',\n\t\t\t\tparams: [input.address, input.cursor, input.limit],\n\t\t\t\tsignal: input.signal,\n\t\t\t});\n\n\t\treturn {\n\t\t\thasNextPage,\n\t\t\tnextCursor,\n\t\t\tdata: data.map((name) => normalizeSuiNSName(name, format)),\n\t\t};\n\t}\n\n\tasync getProtocolConfig(input?: GetProtocolConfigParams): Promise<ProtocolConfig> {\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'sui_getProtocolConfig',\n\t\t\tparams: [input?.version],\n\t\t\tsignal: input?.signal,\n\t\t});\n\t}\n\n\tasync verifyZkLoginSignature(input: VerifyZkLoginSignatureParams): Promise<ZkLoginVerifyResult> {\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'sui_verifyZkLoginSignature',\n\t\t\tparams: [input.bytes, input.signature, input.intentScope, input.author],\n\t\t\tsignal: input.signal,\n\t\t});\n\t}\n\n\t/**\n\t * Wait for a transaction block result to be available over the API.\n\t * This can be used in conjunction with `executeTransactionBlock` to wait for the transaction to\n\t * be available via the API.\n\t * This currently polls the `getTransactionBlock` API to check for the transaction.\n\t */\n\tasync waitForTransaction({\n\t\tsignal,\n\t\ttimeout = 60 * 1000,\n\t\tpollInterval = 2 * 1000,\n\t\t...input\n\t}: {\n\t\t/** An optional abort signal that can be used to cancel */\n\t\tsignal?: AbortSignal;\n\t\t/** The amount of time to wait for a transaction block. Defaults to one minute. */\n\t\ttimeout?: number;\n\t\t/** The amount of time to wait between checks for the transaction block. Defaults to 2 seconds. */\n\t\tpollInterval?: number;\n\t} & Parameters<\n\t\tSuiJsonRpcClient['getTransactionBlock']\n\t>[0]): Promise<SuiTransactionBlockResponse> {\n\t\tconst timeoutSignal = AbortSignal.timeout(timeout);\n\t\tconst timeoutPromise = new Promise((_, reject) => {\n\t\t\ttimeoutSignal.addEventListener('abort', () => reject(timeoutSignal.reason));\n\t\t});\n\n\t\ttimeoutPromise.catch(() => {\n\t\t\t// Swallow unhandled rejections that might be thrown after early return\n\t\t});\n\n\t\twhile (!timeoutSignal.aborted) {\n\t\t\tsignal?.throwIfAborted();\n\t\t\ttry {\n\t\t\t\treturn await this.getTransactionBlock(input);\n\t\t\t} catch {\n\t\t\t\t// Wait for either the next poll interval, or the timeout.\n\t\t\t\tawait Promise.race([\n\t\t\t\t\tnew Promise((resolve) => setTimeout(resolve, pollInterval)),\n\t\t\t\t\ttimeoutPromise,\n\t\t\t\t]);\n\t\t\t}\n\t\t}\n\n\t\ttimeoutSignal.throwIfAborted();\n\n\t\t// This should never happen, because the above case should always throw, but just adding it in the event that something goes horribly wrong.\n\t\tthrow new Error('Unexpected error while waiting for transaction block.');\n\t}\n}\n"],"mappings":"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"}