{"version":3,"file":"rpc-websocket-client.mjs","names":["#setupWebSocket","#requestId","#pendingRequests","#connectionPromise","#webSocket","#disconnects","#reconnect","#subscriptions"],"sources":["../../src/jsonRpc/rpc-websocket-client.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { JsonRpcError } from './errors.js';\n\nfunction getWebsocketUrl(httpUrl: string): string {\n\tconst url = new URL(httpUrl);\n\turl.protocol = url.protocol.replace('http', 'ws');\n\treturn url.toString();\n}\n\ntype JsonRpcMessage =\n\t| {\n\t\t\tid: number;\n\t\t\tresult: never;\n\t\t\terror: {\n\t\t\t\tcode: number;\n\t\t\t\tmessage: string;\n\t\t\t};\n\t  }\n\t| {\n\t\t\tid: number;\n\t\t\tresult: unknown;\n\t\t\terror: never;\n\t  }\n\t| {\n\t\t\tmethod: string;\n\t\t\tparams: NotificationMessageParams;\n\t  };\n\ntype NotificationMessageParams = {\n\tsubscription?: number;\n\tresult: object;\n};\n\ntype SubscriptionRequest<T = any> = {\n\tmethod: string;\n\tunsubscribe: string;\n\tparams: any[];\n\tonMessage: (event: T) => void;\n\tsignal?: AbortSignal;\n};\n\n/**\n * Configuration options for the websocket connection\n */\nexport type WebsocketClientOptions = {\n\t/**\n\t * Custom WebSocket class to use. Defaults to the global WebSocket class, if available.\n\t */\n\tWebSocketConstructor?: typeof WebSocket;\n\t/**\n\t * Milliseconds before timing out while calling an RPC method\n\t */\n\tcallTimeout?: number;\n\t/**\n\t * Milliseconds between attempts to connect\n\t */\n\treconnectTimeout?: number;\n\t/**\n\t * Maximum number of times to try connecting before giving up\n\t */\n\tmaxReconnects?: number;\n};\n\nexport const DEFAULT_CLIENT_OPTIONS = {\n\t// We fudge the typing because we also check for undefined in the constructor:\n\tWebSocketConstructor: (typeof WebSocket !== 'undefined'\n\t\t? WebSocket\n\t\t: undefined) as typeof WebSocket,\n\tcallTimeout: 30000,\n\treconnectTimeout: 3000,\n\tmaxReconnects: 5,\n} satisfies WebsocketClientOptions;\n\nexport class WebsocketClient {\n\tendpoint: string;\n\toptions: Required<WebsocketClientOptions>;\n\t#requestId = 0;\n\t#disconnects = 0;\n\t#webSocket: WebSocket | null = null;\n\t#connectionPromise: Promise<WebSocket> | null = null;\n\t#subscriptions = new Set<RpcSubscription>();\n\t#pendingRequests = new Map<\n\t\tnumber,\n\t\t{\n\t\t\tresolve: (result: Extract<JsonRpcMessage, { id: number }>) => void;\n\t\t\treject: (reason: unknown) => void;\n\t\t\ttimeout: ReturnType<typeof setTimeout>;\n\t\t}\n\t>();\n\n\tconstructor(endpoint: string, options: WebsocketClientOptions = {}) {\n\t\tthis.endpoint = endpoint;\n\t\tthis.options = { ...DEFAULT_CLIENT_OPTIONS, ...options };\n\n\t\tif (!this.options.WebSocketConstructor) {\n\t\t\tthrow new Error('Missing WebSocket constructor');\n\t\t}\n\n\t\tif (this.endpoint.startsWith('http')) {\n\t\t\tthis.endpoint = getWebsocketUrl(this.endpoint);\n\t\t}\n\t}\n\n\tasync makeRequest<T>(method: string, params: any[], signal?: AbortSignal): Promise<T> {\n\t\tconst webSocket = await this.#setupWebSocket();\n\n\t\treturn new Promise<Extract<JsonRpcMessage, { id: number }>>((resolve, reject) => {\n\t\t\tthis.#requestId += 1;\n\t\t\tthis.#pendingRequests.set(this.#requestId, {\n\t\t\t\tresolve: resolve,\n\t\t\t\treject,\n\t\t\t\ttimeout: setTimeout(() => {\n\t\t\t\t\tthis.#pendingRequests.delete(this.#requestId);\n\t\t\t\t\treject(new Error(`Request timeout: ${method}`));\n\t\t\t\t}, this.options.callTimeout),\n\t\t\t});\n\n\t\t\tsignal?.addEventListener('abort', () => {\n\t\t\t\tthis.#pendingRequests.delete(this.#requestId);\n\t\t\t\treject(signal.reason);\n\t\t\t});\n\n\t\t\twebSocket.send(JSON.stringify({ jsonrpc: '2.0', id: this.#requestId, method, params }));\n\t\t}).then(({ error, result }) => {\n\t\t\tif (error) {\n\t\t\t\tthrow new JsonRpcError(error.message, error.code);\n\t\t\t}\n\n\t\t\treturn result as T;\n\t\t});\n\t}\n\n\t#setupWebSocket() {\n\t\tif (this.#connectionPromise) {\n\t\t\treturn this.#connectionPromise;\n\t\t}\n\n\t\tthis.#connectionPromise = new Promise<WebSocket>((resolve) => {\n\t\t\tthis.#webSocket?.close();\n\t\t\tthis.#webSocket = new this.options.WebSocketConstructor(this.endpoint);\n\n\t\t\tthis.#webSocket.addEventListener('open', () => {\n\t\t\t\tthis.#disconnects = 0;\n\t\t\t\tresolve(this.#webSocket!);\n\t\t\t});\n\n\t\t\tthis.#webSocket.addEventListener('close', () => {\n\t\t\t\tthis.#disconnects++;\n\t\t\t\tif (this.#disconnects <= this.options.maxReconnects) {\n\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\tthis.#reconnect();\n\t\t\t\t\t}, this.options.reconnectTimeout);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tthis.#webSocket.addEventListener('message', ({ data }: { data: string }) => {\n\t\t\t\tlet json: JsonRpcMessage;\n\t\t\t\ttry {\n\t\t\t\t\tjson = JSON.parse(data) as JsonRpcMessage;\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.error(new Error(`Failed to parse RPC message: ${data}`, { cause: error }));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif ('id' in json && json.id != null && this.#pendingRequests.has(json.id)) {\n\t\t\t\t\tconst { resolve, timeout } = this.#pendingRequests.get(json.id)!;\n\n\t\t\t\t\tclearTimeout(timeout);\n\t\t\t\t\tresolve(json);\n\t\t\t\t} else if ('params' in json) {\n\t\t\t\t\tconst { params } = json;\n\t\t\t\t\tthis.#subscriptions.forEach((subscription) => {\n\t\t\t\t\t\tif (subscription.subscriptionId === params.subscription)\n\t\t\t\t\t\t\tif (params.subscription === subscription.subscriptionId) {\n\t\t\t\t\t\t\t\tsubscription.onMessage(params.result);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\treturn this.#connectionPromise;\n\t}\n\n\tasync #reconnect() {\n\t\tthis.#webSocket?.close();\n\t\tthis.#connectionPromise = null;\n\n\t\treturn Promise.allSettled(\n\t\t\t[...this.#subscriptions].map((subscription) => subscription.subscribe(this)),\n\t\t);\n\t}\n\n\tasync subscribe<T>(input: SubscriptionRequest<T>) {\n\t\tconst subscription = new RpcSubscription(input);\n\t\tthis.#subscriptions.add(subscription);\n\t\tawait subscription.subscribe(this);\n\t\treturn () => subscription.unsubscribe(this);\n\t}\n}\n\nclass RpcSubscription {\n\tsubscriptionId: number | null = null;\n\tinput: SubscriptionRequest<any>;\n\tsubscribed = false;\n\n\tconstructor(input: SubscriptionRequest) {\n\t\tthis.input = input;\n\t}\n\n\tonMessage(message: unknown) {\n\t\tif (this.subscribed) {\n\t\t\tthis.input.onMessage(message);\n\t\t}\n\t}\n\n\tasync unsubscribe(client: WebsocketClient) {\n\t\tconst { subscriptionId } = this;\n\t\tthis.subscribed = false;\n\t\tif (subscriptionId == null) return false;\n\t\tthis.subscriptionId = null;\n\n\t\treturn client.makeRequest(this.input.unsubscribe, [subscriptionId]);\n\t}\n\n\tasync subscribe(client: WebsocketClient) {\n\t\tthis.subscriptionId = null;\n\t\tthis.subscribed = true;\n\t\tconst newSubscriptionId = await client.makeRequest<number>(\n\t\t\tthis.input.method,\n\t\t\tthis.input.params,\n\t\t\tthis.input.signal,\n\t\t);\n\n\t\tif (this.subscribed) {\n\t\t\tthis.subscriptionId = newSubscriptionId;\n\t\t}\n\t}\n}\n"],"mappings":"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"}