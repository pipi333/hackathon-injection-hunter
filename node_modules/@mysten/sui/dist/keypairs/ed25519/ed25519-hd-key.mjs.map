{"version":3,"file":"ed25519-hd-key.mjs","names":[],"sources":["../../../src/keypairs/ed25519/ed25519-hd-key.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n// This is adapted from https://github.com/alepop/ed25519-hd-key replacing create-hmac\n// with @noble/hashes to be browser compatible.\n\nimport { fromHex } from '@mysten/bcs';\nimport { hmac } from '@noble/hashes/hmac.js';\nimport { sha512 } from '@noble/hashes/sha2.js';\n\ntype Hex = string;\ntype Path = string;\n\ntype Keys = {\n\tkey: Uint8Array;\n\tchainCode: Uint8Array;\n};\n\nconst ED25519_CURVE = 'ed25519 seed';\nconst HARDENED_OFFSET = 0x80000000;\n\nconst pathRegex = new RegExp(\"^m(\\\\/[0-9]+')+$\");\n\nconst replaceDerive = (val: string): string => val.replace(\"'\", '');\n\nconst getMasterKeyFromSeed = (seed: Hex): Keys => {\n\tconst h = hmac.create(sha512, new TextEncoder().encode(ED25519_CURVE));\n\tconst I = h.update(fromHex(seed)).digest();\n\tconst IL = I.slice(0, 32);\n\tconst IR = I.slice(32);\n\treturn {\n\t\tkey: IL,\n\t\tchainCode: IR,\n\t};\n};\n\nconst CKDPriv = ({ key, chainCode }: Keys, index: number): Keys => {\n\tconst indexBuffer = new ArrayBuffer(4);\n\tconst cv = new DataView(indexBuffer);\n\tcv.setUint32(0, index);\n\n\tconst data = new Uint8Array(1 + key.length + indexBuffer.byteLength);\n\tdata.set(new Uint8Array(1).fill(0));\n\tdata.set(key, 1);\n\tdata.set(new Uint8Array(indexBuffer, 0, indexBuffer.byteLength), key.length + 1);\n\n\tconst I = hmac.create(sha512, chainCode).update(data).digest();\n\tconst IL = I.slice(0, 32);\n\tconst IR = I.slice(32);\n\treturn {\n\t\tkey: IL,\n\t\tchainCode: IR,\n\t};\n};\n\nconst isValidPath = (path: string): boolean => {\n\tif (!pathRegex.test(path)) {\n\t\treturn false;\n\t}\n\treturn !path\n\t\t.split('/')\n\t\t.slice(1)\n\t\t.map(replaceDerive)\n\t\t.some(isNaN as any /* ts T_T*/);\n};\n\nexport const derivePath = (path: Path, seed: Hex, offset = HARDENED_OFFSET): Keys => {\n\tif (!isValidPath(path)) {\n\t\tthrow new Error('Invalid derivation path');\n\t}\n\n\tconst { key, chainCode } = getMasterKeyFromSeed(seed);\n\tconst segments = path\n\t\t.split('/')\n\t\t.slice(1)\n\t\t.map(replaceDerive)\n\t\t.map((el) => parseInt(el, 10));\n\n\treturn segments.reduce((parentKeys, segment) => CKDPriv(parentKeys, segment + offset), {\n\t\tkey,\n\t\tchainCode,\n\t});\n};\n"],"mappings":";;;;;AAkBA,MAAM,gBAAgB;AACtB,MAAM,kBAAkB;AAExB,MAAM,4BAAY,IAAI,OAAO,mBAAmB;AAEhD,MAAM,iBAAiB,QAAwB,IAAI,QAAQ,KAAK,GAAG;AAEnE,MAAM,wBAAwB,SAAoB;CAEjD,MAAM,IADI,KAAK,OAAO,QAAQ,IAAI,aAAa,CAAC,OAAO,cAAc,CAAC,CAC1D,OAAO,QAAQ,KAAK,CAAC,CAAC,QAAQ;AAG1C,QAAO;EACN,KAHU,EAAE,MAAM,GAAG,GAAG;EAIxB,WAHU,EAAE,MAAM,GAAG;EAIrB;;AAGF,MAAM,WAAW,EAAE,KAAK,aAAmB,UAAwB;CAClE,MAAM,8BAAc,IAAI,YAAY,EAAE;AAEtC,CADW,IAAI,SAAS,YAAY,CACjC,UAAU,GAAG,MAAM;CAEtB,MAAM,OAAO,IAAI,WAAW,IAAI,IAAI,SAAS,YAAY,WAAW;AACpE,MAAK,IAAI,IAAI,WAAW,EAAE,CAAC,KAAK,EAAE,CAAC;AACnC,MAAK,IAAI,KAAK,EAAE;AAChB,MAAK,IAAI,IAAI,WAAW,aAAa,GAAG,YAAY,WAAW,EAAE,IAAI,SAAS,EAAE;CAEhF,MAAM,IAAI,KAAK,OAAO,QAAQ,UAAU,CAAC,OAAO,KAAK,CAAC,QAAQ;AAG9D,QAAO;EACN,KAHU,EAAE,MAAM,GAAG,GAAG;EAIxB,WAHU,EAAE,MAAM,GAAG;EAIrB;;AAGF,MAAM,eAAe,SAA0B;AAC9C,KAAI,CAAC,UAAU,KAAK,KAAK,CACxB,QAAO;AAER,QAAO,CAAC,KACN,MAAM,IAAI,CACV,MAAM,EAAE,CACR,IAAI,cAAc,CAClB,KAAK,MAAyB;;AAGjC,MAAa,cAAc,MAAY,MAAW,SAAS,oBAA0B;AACpF,KAAI,CAAC,YAAY,KAAK,CACrB,OAAM,IAAI,MAAM,0BAA0B;CAG3C,MAAM,EAAE,KAAK,cAAc,qBAAqB,KAAK;AAOrD,QANiB,KACf,MAAM,IAAI,CACV,MAAM,EAAE,CACR,IAAI,cAAc,CAClB,KAAK,OAAO,SAAS,IAAI,GAAG,CAAC,CAEf,QAAQ,YAAY,YAAY,QAAQ,YAAY,UAAU,OAAO,EAAE;EACtF;EACA;EACA,CAAC"}