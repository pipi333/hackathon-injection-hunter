{"version":3,"file":"publickey.mjs","names":[],"sources":["../../../src/keypairs/secp256k1/publickey.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase64 } from '@mysten/bcs';\nimport { secp256k1 } from '@noble/curves/secp256k1.js';\n\nimport {\n\tbytesEqual,\n\tparseSerializedKeypairSignature,\n\tPublicKey,\n} from '../../cryptography/publickey.js';\nimport type { PublicKeyInitData } from '../../cryptography/publickey.js';\nimport { SIGNATURE_SCHEME_TO_FLAG } from '../../cryptography/signature-scheme.js';\n\nconst SECP256K1_PUBLIC_KEY_SIZE = 33;\n\n/**\n * A Secp256k1 public key\n */\nexport class Secp256k1PublicKey extends PublicKey {\n\tstatic SIZE = SECP256K1_PUBLIC_KEY_SIZE;\n\tprivate data: Uint8Array<ArrayBuffer>;\n\n\t/**\n\t * Create a new Secp256k1PublicKey object\n\t * @param value secp256k1 public key as buffer or base-64 encoded string\n\t */\n\tconstructor(value: PublicKeyInitData) {\n\t\tsuper();\n\n\t\tif (typeof value === 'string') {\n\t\t\tthis.data = fromBase64(value);\n\t\t} else if (value instanceof Uint8Array) {\n\t\t\tthis.data = value as Uint8Array<ArrayBuffer>;\n\t\t} else {\n\t\t\tthis.data = Uint8Array.from(value);\n\t\t}\n\n\t\tif (this.data.length !== SECP256K1_PUBLIC_KEY_SIZE) {\n\t\t\tthrow new Error(\n\t\t\t\t`Invalid public key input. Expected ${SECP256K1_PUBLIC_KEY_SIZE} bytes, got ${this.data.length}`,\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Checks if two Secp256k1 public keys are equal\n\t */\n\toverride equals(publicKey: Secp256k1PublicKey): boolean {\n\t\treturn super.equals(publicKey);\n\t}\n\n\t/**\n\t * Return the byte array representation of the Secp256k1 public key\n\t */\n\ttoRawBytes(): Uint8Array<ArrayBuffer> {\n\t\treturn this.data;\n\t}\n\n\t/**\n\t * Return the Sui address associated with this Secp256k1 public key\n\t */\n\tflag(): number {\n\t\treturn SIGNATURE_SCHEME_TO_FLAG['Secp256k1'];\n\t}\n\n\t/**\n\t * Verifies that the signature is valid for for the provided message\n\t */\n\tasync verify(message: Uint8Array, signature: Uint8Array | string): Promise<boolean> {\n\t\tlet bytes;\n\t\tif (typeof signature === 'string') {\n\t\t\tconst parsed = parseSerializedKeypairSignature(signature);\n\t\t\tif (parsed.signatureScheme !== 'Secp256k1') {\n\t\t\t\tthrow new Error('Invalid signature scheme');\n\t\t\t}\n\n\t\t\tif (!bytesEqual(this.toRawBytes(), parsed.publicKey)) {\n\t\t\t\tthrow new Error('Signature does not match public key');\n\t\t\t}\n\n\t\t\tbytes = parsed.signature;\n\t\t} else {\n\t\t\tbytes = signature;\n\t\t}\n\n\t\treturn secp256k1.verify(bytes, message, this.toRawBytes());\n\t}\n}\n"],"mappings":";;;;;;AAcA,MAAM,4BAA4B;;;;AAKlC,IAAa,qBAAb,cAAwC,UAAU;;cACnC;;;;;;CAOd,YAAY,OAA0B;AACrC,SAAO;AAEP,MAAI,OAAO,UAAU,SACpB,MAAK,OAAO,WAAW,MAAM;WACnB,iBAAiB,WAC3B,MAAK,OAAO;MAEZ,MAAK,OAAO,WAAW,KAAK,MAAM;AAGnC,MAAI,KAAK,KAAK,WAAW,0BACxB,OAAM,IAAI,MACT,sCAAsC,0BAA0B,cAAc,KAAK,KAAK,SACxF;;;;;CAOH,AAAS,OAAO,WAAwC;AACvD,SAAO,MAAM,OAAO,UAAU;;;;;CAM/B,aAAsC;AACrC,SAAO,KAAK;;;;;CAMb,OAAe;AACd,SAAO,yBAAyB;;;;;CAMjC,MAAM,OAAO,SAAqB,WAAkD;EACnF,IAAI;AACJ,MAAI,OAAO,cAAc,UAAU;GAClC,MAAM,SAAS,gCAAgC,UAAU;AACzD,OAAI,OAAO,oBAAoB,YAC9B,OAAM,IAAI,MAAM,2BAA2B;AAG5C,OAAI,CAAC,WAAW,KAAK,YAAY,EAAE,OAAO,UAAU,CACnD,OAAM,IAAI,MAAM,sCAAsC;AAGvD,WAAQ,OAAO;QAEf,SAAQ;AAGT,SAAO,UAAU,OAAO,OAAO,SAAS,KAAK,YAAY,CAAC"}