{"version":3,"file":"keypair.mjs","names":[],"sources":["../../../src/keypairs/secp256k1/keypair.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { secp256k1 } from '@noble/curves/secp256k1.js';\nimport { blake2b } from '@noble/hashes/blake2.js';\nimport { HDKey } from '@scure/bip32';\n\nimport { decodeSuiPrivateKey, encodeSuiPrivateKey, Keypair } from '../../cryptography/keypair.js';\nimport { isValidBIP32Path, mnemonicToSeed } from '../../cryptography/mnemonics.js';\nimport type { PublicKey } from '../../cryptography/publickey.js';\nimport type { SignatureScheme } from '../../cryptography/signature-scheme.js';\nimport { Secp256k1PublicKey } from './publickey.js';\n\nexport const DEFAULT_SECP256K1_DERIVATION_PATH = \"m/54'/784'/0'/0/0\";\n\n/**\n * Secp256k1 Keypair data\n */\nexport interface Secp256k1KeypairData {\n\tpublicKey: Uint8Array;\n\tsecretKey: Uint8Array;\n}\n\n/**\n * An Secp256k1 Keypair used for signing transactions.\n */\nexport class Secp256k1Keypair extends Keypair {\n\tprivate keypair: Secp256k1KeypairData;\n\n\t/**\n\t * Create a new keypair instance.\n\t * Generate random keypair if no {@link Secp256k1Keypair} is provided.\n\t *\n\t * @param keypair secp256k1 keypair\n\t */\n\tconstructor(keypair?: Secp256k1KeypairData) {\n\t\tsuper();\n\t\tif (keypair) {\n\t\t\tthis.keypair = keypair;\n\t\t} else {\n\t\t\tconst secretKey: Uint8Array = secp256k1.utils.randomSecretKey();\n\t\t\tconst publicKey: Uint8Array = secp256k1.getPublicKey(secretKey, true);\n\n\t\t\tthis.keypair = { publicKey, secretKey };\n\t\t}\n\t}\n\n\t/**\n\t * Get the key scheme of the keypair Secp256k1\n\t */\n\tgetKeyScheme(): SignatureScheme {\n\t\treturn 'Secp256k1';\n\t}\n\n\t/**\n\t * Generate a new random keypair\n\t */\n\tstatic generate(): Secp256k1Keypair {\n\t\treturn new Secp256k1Keypair();\n\t}\n\n\t/**\n\t * Create a keypair from a raw secret key byte array.\n\t *\n\t * This method should only be used to recreate a keypair from a previously\n\t * generated secret key. Generating keypairs from a random seed should be done\n\t * with the {@link Keypair.fromSeed} method.\n\t *\n\t * @throws error if the provided secret key is invalid and validation is not skipped.\n\t *\n\t * @param secretKey secret key byte array  or Bech32 secret key string\n\t * @param options: skip secret key validation\n\t */\n\n\tstatic fromSecretKey(\n\t\tsecretKey: Uint8Array | string,\n\t\toptions?: { skipValidation?: boolean },\n\t): Secp256k1Keypair {\n\t\tif (typeof secretKey === 'string') {\n\t\t\tconst decoded = decodeSuiPrivateKey(secretKey);\n\n\t\t\tif (decoded.scheme !== 'Secp256k1') {\n\t\t\t\tthrow new Error(`Expected a Secp256k1 keypair, got ${decoded.scheme}`);\n\t\t\t}\n\n\t\t\treturn this.fromSecretKey(decoded.secretKey, options);\n\t\t}\n\n\t\tconst publicKey: Uint8Array = secp256k1.getPublicKey(secretKey, true);\n\t\tif (!options || !options.skipValidation) {\n\t\t\tconst encoder = new TextEncoder();\n\t\t\tconst signData = encoder.encode('sui validation');\n\t\t\tconst msgHash = blake2b(signData, { dkLen: 32 });\n\t\t\tconst signature = secp256k1.sign(msgHash, secretKey, { prehash: false });\n\n\t\t\tif (!secp256k1.verify(signature, msgHash, publicKey, { lowS: true, prehash: false })) {\n\t\t\t\tthrow new Error('Provided secretKey is invalid');\n\t\t\t}\n\t\t}\n\t\treturn new Secp256k1Keypair({ publicKey, secretKey });\n\t}\n\n\t/**\n\t * Generate a keypair from a 32 byte seed.\n\t *\n\t * @param seed seed byte array\n\t */\n\tstatic fromSeed(seed: Uint8Array): Secp256k1Keypair {\n\t\tconst publicKey = secp256k1.getPublicKey(seed, true);\n\t\treturn new Secp256k1Keypair({ publicKey, secretKey: seed });\n\t}\n\n\t/**\n\t * The public key for this keypair\n\t */\n\tgetPublicKey(): PublicKey {\n\t\treturn new Secp256k1PublicKey(this.keypair.publicKey);\n\t}\n\t/**\n\t * The Bech32 secret key string for this Secp256k1 keypair\n\t */\n\tgetSecretKey(): string {\n\t\treturn encodeSuiPrivateKey(this.keypair.secretKey, this.getKeyScheme());\n\t}\n\n\t/**\n\t * Return the signature for the provided data.\n\t */\n\tasync sign(data: Uint8Array) {\n\t\treturn secp256k1.sign(data, this.keypair.secretKey, {\n\t\t\tlowS: true,\n\t\t}) as Uint8Array<ArrayBuffer>;\n\t}\n\n\t/**\n\t * Derive Secp256k1 keypair from mnemonics and path. The mnemonics must be normalized\n\t * and validated against the english wordlist.\n\t *\n\t * If path is none, it will default to m/54'/784'/0'/0/0, otherwise the path must\n\t * be compliant to BIP-32 in form m/54'/784'/{account_index}'/{change_index}/{address_index}.\n\t */\n\tstatic deriveKeypair(mnemonics: string, path?: string): Secp256k1Keypair {\n\t\tif (path == null) {\n\t\t\tpath = DEFAULT_SECP256K1_DERIVATION_PATH;\n\t\t}\n\t\tif (!isValidBIP32Path(path)) {\n\t\t\tthrow new Error('Invalid derivation path');\n\t\t}\n\t\tconst key = HDKey.fromMasterSeed(mnemonicToSeed(mnemonics)).derive(path);\n\t\tif (key.publicKey == null || key.privateKey == null) {\n\t\t\tthrow new Error('Invalid key');\n\t\t}\n\t\treturn new Secp256k1Keypair({\n\t\t\tpublicKey: key.publicKey,\n\t\t\tsecretKey: key.privateKey,\n\t\t});\n\t}\n}\n"],"mappings":";;;;;;;;AAaA,MAAa,oCAAoC;;;;AAajD,IAAa,mBAAb,MAAa,yBAAyB,QAAQ;;;;;;;CAS7C,YAAY,SAAgC;AAC3C,SAAO;AACP,MAAI,QACH,MAAK,UAAU;OACT;GACN,MAAM,YAAwB,UAAU,MAAM,iBAAiB;AAG/D,QAAK,UAAU;IAAE,WAFa,UAAU,aAAa,WAAW,KAAK;IAEzC;IAAW;;;;;;CAOzC,eAAgC;AAC/B,SAAO;;;;;CAMR,OAAO,WAA6B;AACnC,SAAO,IAAI,kBAAkB;;;;;;;;;;;;;;CAgB9B,OAAO,cACN,WACA,SACmB;AACnB,MAAI,OAAO,cAAc,UAAU;GAClC,MAAM,UAAU,oBAAoB,UAAU;AAE9C,OAAI,QAAQ,WAAW,YACtB,OAAM,IAAI,MAAM,qCAAqC,QAAQ,SAAS;AAGvE,UAAO,KAAK,cAAc,QAAQ,WAAW,QAAQ;;EAGtD,MAAM,YAAwB,UAAU,aAAa,WAAW,KAAK;AACrE,MAAI,CAAC,WAAW,CAAC,QAAQ,gBAAgB;GAGxC,MAAM,UAAU,QAFA,IAAI,aAAa,CACR,OAAO,iBAAiB,EACf,EAAE,OAAO,IAAI,CAAC;GAChD,MAAM,YAAY,UAAU,KAAK,SAAS,WAAW,EAAE,SAAS,OAAO,CAAC;AAExE,OAAI,CAAC,UAAU,OAAO,WAAW,SAAS,WAAW;IAAE,MAAM;IAAM,SAAS;IAAO,CAAC,CACnF,OAAM,IAAI,MAAM,gCAAgC;;AAGlD,SAAO,IAAI,iBAAiB;GAAE;GAAW;GAAW,CAAC;;;;;;;CAQtD,OAAO,SAAS,MAAoC;AAEnD,SAAO,IAAI,iBAAiB;GAAE,WADZ,UAAU,aAAa,MAAM,KAAK;GACX,WAAW;GAAM,CAAC;;;;;CAM5D,eAA0B;AACzB,SAAO,IAAI,mBAAmB,KAAK,QAAQ,UAAU;;;;;CAKtD,eAAuB;AACtB,SAAO,oBAAoB,KAAK,QAAQ,WAAW,KAAK,cAAc,CAAC;;;;;CAMxE,MAAM,KAAK,MAAkB;AAC5B,SAAO,UAAU,KAAK,MAAM,KAAK,QAAQ,WAAW,EACnD,MAAM,MACN,CAAC;;;;;;;;;CAUH,OAAO,cAAc,WAAmB,MAAiC;AACxE,MAAI,QAAQ,KACX,QAAO;AAER,MAAI,CAAC,iBAAiB,KAAK,CAC1B,OAAM,IAAI,MAAM,0BAA0B;EAE3C,MAAM,MAAM,MAAM,eAAe,eAAe,UAAU,CAAC,CAAC,OAAO,KAAK;AACxE,MAAI,IAAI,aAAa,QAAQ,IAAI,cAAc,KAC9C,OAAM,IAAI,MAAM,cAAc;AAE/B,SAAO,IAAI,iBAAiB;GAC3B,WAAW,IAAI;GACf,WAAW,IAAI;GACf,CAAC"}