{"version":3,"file":"Transaction.mjs","names":["#data","#inputSection","#commandSection","#availableResults","#serializationPlugins","#buildPlugins","#intentResolvers","#addInput","#pendingPromises","#added","#fork","#addCommand","result","#resolveArgument","#normalizeTransactionArgument","#prepareBuild","#runPlugins","#waitForPendingTasks","#sortCommandsAndInputs"],"sources":["../../src/transactions/Transaction.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { SerializedBcs } from '@mysten/bcs';\nimport { fromBase64, isSerializedBcs } from '@mysten/bcs';\nimport type { InferInput } from 'valibot';\nimport { is, parse } from 'valibot';\n\nimport type { SignatureWithBytes, Signer } from '../cryptography/index.js';\nimport { normalizeSuiAddress } from '../utils/sui-types.js';\nimport type { TransactionArgument } from './Commands.js';\nimport { TransactionCommands } from './Commands.js';\nimport type { CallArg, Command, Argument, ObjectRef } from './data/internal.js';\nimport {\n\tArgumentSchema,\n\tNormalizedCallArg,\n\tObjectRefSchema,\n\tTransactionExpiration,\n} from './data/internal.js';\nimport { serializeV1TransactionData } from './data/v1.js';\nimport { SerializedTransactionDataV2Schema } from './data/v2.js';\nimport { Inputs } from './Inputs.js';\nimport { needsTransactionResolution, resolveTransactionPlugin } from './resolve.js';\nimport type {\n\tBuildTransactionOptions,\n\tSerializeTransactionOptions,\n\tTransactionPlugin,\n} from './resolve.js';\nimport { createObjectMethods } from './object.js';\nimport { createPure } from './pure.js';\nimport { TransactionDataBuilder } from './TransactionData.js';\nimport { getIdFromCallArg } from './utils.js';\nimport { namedPackagesPlugin } from './plugins/NamedPackagesPlugin.js';\nimport { COIN_WITH_BALANCE, resolveCoinBalance } from './intents/CoinWithBalance.js';\nimport type { ClientWithCoreApi } from '../client/core.js';\n\nexport type TransactionObjectArgument =\n\t| Exclude<InferInput<typeof ArgumentSchema>, { Input: unknown; type?: 'pure' }>\n\t| ((\n\t\t\ttx: Transaction,\n\t  ) => Exclude<InferInput<typeof ArgumentSchema>, { Input: unknown; type?: 'pure' }>)\n\t| AsyncTransactionThunk<TransactionResultArgument>;\n\nexport type TransactionResult = Extract<Argument, { Result: unknown }> &\n\tExtract<Argument, { NestedResult: unknown }>[];\n\nexport type TransactionResultArgument =\n\t| Extract<Argument, { Result: unknown }>\n\t| readonly Extract<Argument, { NestedResult: unknown }>[];\n\nexport type AsyncTransactionThunk<\n\tT extends TransactionResultArgument | void = TransactionResultArgument | void,\n> = (tx: Transaction) => Promise<T | void>;\n\nfunction createTransactionResult(\n\tindex: number | (() => number),\n\tlength = Infinity,\n): TransactionResult {\n\tconst baseResult = {\n\t\t$kind: 'Result' as const,\n\t\tget Result() {\n\t\t\treturn typeof index === 'function' ? index() : index;\n\t\t},\n\t};\n\n\tconst nestedResults: {\n\t\t$kind: 'NestedResult';\n\t\tNestedResult: [number, number];\n\t}[] = [];\n\tconst nestedResultFor = (\n\t\tresultIndex: number,\n\t): {\n\t\t$kind: 'NestedResult';\n\t\tNestedResult: [number, number];\n\t} =>\n\t\t(nestedResults[resultIndex] ??= {\n\t\t\t$kind: 'NestedResult' as const,\n\t\t\tget NestedResult() {\n\t\t\t\treturn [typeof index === 'function' ? index() : index, resultIndex] as [number, number];\n\t\t\t},\n\t\t});\n\n\treturn new Proxy(baseResult, {\n\t\tset() {\n\t\t\tthrow new Error(\n\t\t\t\t'The transaction result is a proxy, and does not support setting properties directly',\n\t\t\t);\n\t\t},\n\t\t// TODO: Instead of making this return a concrete argument, we should ideally\n\t\t// make it reference-based (so that this gets resolved at build-time), which\n\t\t// allows re-ordering transactions.\n\t\tget(target, property) {\n\t\t\t// This allows this transaction argument to be used in the singular form:\n\t\t\tif (property in target) {\n\t\t\t\treturn Reflect.get(target, property);\n\t\t\t}\n\n\t\t\t// Support destructuring:\n\t\t\tif (property === Symbol.iterator) {\n\t\t\t\treturn function* () {\n\t\t\t\t\tlet i = 0;\n\t\t\t\t\twhile (i < length) {\n\t\t\t\t\t\tyield nestedResultFor(i);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (typeof property === 'symbol') return;\n\n\t\t\tconst resultIndex = parseInt(property, 10);\n\t\t\tif (Number.isNaN(resultIndex) || resultIndex < 0) return;\n\t\t\treturn nestedResultFor(resultIndex);\n\t\t},\n\t}) as TransactionResult;\n}\n\nconst TRANSACTION_BRAND = Symbol.for('@mysten/transaction') as never;\n\ninterface SignOptions extends BuildTransactionOptions {\n\tsigner: Signer;\n}\n\nexport function isTransaction(obj: unknown): obj is TransactionLike {\n\treturn !!obj && typeof obj === 'object' && (obj as any)[TRANSACTION_BRAND] === true;\n}\n\nexport type TransactionObjectInput = string | CallArg | TransactionObjectArgument;\n\ntype InputSection = (CallArg | InputSection)[];\ntype CommandSection = (Command | CommandSection)[];\n\ntype TransactionLike = {\n\tgetData(): unknown;\n};\n\n/**\n * Transaction Builder\n */\nexport class Transaction {\n\t#serializationPlugins: TransactionPlugin[];\n\t#buildPlugins: TransactionPlugin[];\n\t#intentResolvers = new Map<string, TransactionPlugin>();\n\t#inputSection: InputSection = [];\n\t#commandSection: CommandSection = [];\n\t#availableResults: Set<number> = new Set();\n\t#pendingPromises = new Set<Promise<unknown>>();\n\t#added = new Map<(...args: any[]) => unknown, unknown>();\n\n\t/**\n\t * Converts from a serialize transaction kind (built with `build({ onlyTransactionKind: true })`) to a `Transaction` class.\n\t * Supports either a byte array, or base64-encoded bytes.\n\t */\n\tstatic fromKind(serialized: string | Uint8Array) {\n\t\tconst tx = new Transaction();\n\n\t\ttx.#data = TransactionDataBuilder.fromKindBytes(\n\t\t\ttypeof serialized === 'string' ? fromBase64(serialized) : serialized,\n\t\t);\n\n\t\ttx.#inputSection = tx.#data.inputs.slice();\n\t\ttx.#commandSection = tx.#data.commands.slice();\n\t\ttx.#availableResults = new Set(tx.#commandSection.map((_, i) => i));\n\n\t\treturn tx;\n\t}\n\n\t/**\n\t * Converts from a serialized transaction format to a `Transaction` class.\n\t * There are two supported serialized formats:\n\t * - A string returned from `Transaction#serialize`. The serialized format must be compatible, or it will throw an error.\n\t * - A byte array (or base64-encoded bytes) containing BCS transaction data.\n\t */\n\tstatic from(transaction: string | Uint8Array | TransactionLike) {\n\t\tconst newTransaction = new Transaction();\n\n\t\tif (isTransaction(transaction)) {\n\t\t\tnewTransaction.#data = TransactionDataBuilder.restore(\n\t\t\t\ttransaction.getData() as InferInput<typeof SerializedTransactionDataV2Schema>,\n\t\t\t);\n\t\t} else if (typeof transaction !== 'string' || !transaction.startsWith('{')) {\n\t\t\tnewTransaction.#data = TransactionDataBuilder.fromBytes(\n\t\t\t\ttypeof transaction === 'string' ? fromBase64(transaction) : transaction,\n\t\t\t);\n\t\t} else {\n\t\t\tnewTransaction.#data = TransactionDataBuilder.restore(JSON.parse(transaction));\n\t\t}\n\n\t\tnewTransaction.#inputSection = newTransaction.#data.inputs.slice();\n\t\tnewTransaction.#commandSection = newTransaction.#data.commands.slice();\n\t\tnewTransaction.#availableResults = new Set(newTransaction.#commandSection.map((_, i) => i));\n\n\t\tif (!newTransaction.isPreparedForSerialization({ supportedIntents: [COIN_WITH_BALANCE] })) {\n\t\t\tthrow new Error(\n\t\t\t\t'Transaction has unresolved intents or async thunks. Call `prepareForSerialization` before copying.',\n\t\t\t);\n\t\t}\n\n\t\tif (newTransaction.#data.commands.some((cmd) => cmd.$Intent?.name === COIN_WITH_BALANCE)) {\n\t\t\tnewTransaction.addIntentResolver(COIN_WITH_BALANCE, resolveCoinBalance);\n\t\t}\n\n\t\treturn newTransaction;\n\t}\n\n\taddSerializationPlugin(step: TransactionPlugin) {\n\t\tthis.#serializationPlugins.push(step);\n\t}\n\n\taddBuildPlugin(step: TransactionPlugin) {\n\t\tthis.#buildPlugins.push(step);\n\t}\n\n\taddIntentResolver(intent: string, resolver: TransactionPlugin) {\n\t\tif (this.#intentResolvers.has(intent) && this.#intentResolvers.get(intent) !== resolver) {\n\t\t\tthrow new Error(`Intent resolver for ${intent} already exists`);\n\t\t}\n\n\t\tthis.#intentResolvers.set(intent, resolver);\n\t}\n\n\tsetSender(sender: string) {\n\t\tthis.#data.sender = sender;\n\t}\n\t/**\n\t * Sets the sender only if it has not already been set.\n\t * This is useful for sponsored transaction flows where the sender may not be the same as the signer address.\n\t */\n\tsetSenderIfNotSet(sender: string) {\n\t\tif (!this.#data.sender) {\n\t\t\tthis.#data.sender = sender;\n\t\t}\n\t}\n\tsetExpiration(expiration?: InferInput<typeof TransactionExpiration> | null) {\n\t\tthis.#data.expiration = expiration ? parse(TransactionExpiration, expiration) : null;\n\t}\n\tsetGasPrice(price: number | bigint | string) {\n\t\tthis.#data.gasData.price = String(price);\n\t}\n\tsetGasBudget(budget: number | bigint | string) {\n\t\tthis.#data.gasData.budget = String(budget);\n\t}\n\n\tsetGasBudgetIfNotSet(budget: number | bigint | string) {\n\t\tif (this.#data.gasData.budget == null) {\n\t\t\tthis.#data.gasData.budget = String(budget);\n\t\t}\n\t}\n\n\tsetGasOwner(owner: string) {\n\t\tthis.#data.gasData.owner = owner;\n\t}\n\tsetGasPayment(payments: ObjectRef[]) {\n\t\tthis.#data.gasData.payment = payments.map((payment) => parse(ObjectRefSchema, payment));\n\t}\n\n\t#data: TransactionDataBuilder;\n\n\t/** Get a snapshot of the transaction data, in JSON form: */\n\tgetData() {\n\t\treturn this.#data.snapshot();\n\t}\n\n\t// Used to brand transaction classes so that they can be identified, even between multiple copies\n\t// of the builder.\n\tget [TRANSACTION_BRAND]() {\n\t\treturn true;\n\t}\n\n\t// Temporary workaround for the wallet interface accidentally serializing transactions via postMessage\n\tget pure(): ReturnType<typeof createPure<Argument>> {\n\t\tObject.defineProperty(this, 'pure', {\n\t\t\tenumerable: false,\n\t\t\tvalue: createPure<Argument>((value): Argument => {\n\t\t\t\tif (isSerializedBcs(value)) {\n\t\t\t\t\treturn this.#addInput('pure', {\n\t\t\t\t\t\t$kind: 'Pure',\n\t\t\t\t\t\tPure: {\n\t\t\t\t\t\t\tbytes: value.toBase64(),\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// TODO: we can also do some deduplication here\n\t\t\t\treturn this.#addInput(\n\t\t\t\t\t'pure',\n\t\t\t\t\tis(NormalizedCallArg, value)\n\t\t\t\t\t\t? parse(NormalizedCallArg, value)\n\t\t\t\t\t\t: value instanceof Uint8Array\n\t\t\t\t\t\t\t? Inputs.Pure(value)\n\t\t\t\t\t\t\t: { $kind: 'UnresolvedPure', UnresolvedPure: { value } },\n\t\t\t\t);\n\t\t\t}),\n\t\t});\n\n\t\treturn this.pure;\n\t}\n\n\tconstructor() {\n\t\tthis.#data = new TransactionDataBuilder();\n\t\tthis.#buildPlugins = [];\n\t\tthis.#serializationPlugins = [];\n\t}\n\n\t/** Returns an argument for the gas coin, to be used in a transaction. */\n\tget gas() {\n\t\treturn { $kind: 'GasCoin' as const, GasCoin: true as const };\n\t}\n\n\t/**\n\t * Add a new object input to the transaction.\n\t */\n\tobject: ReturnType<\n\t\ttypeof createObjectMethods<{ $kind: 'Input'; Input: number; type?: 'object' }>\n\t> = createObjectMethods(\n\t\t(value: TransactionObjectInput): { $kind: 'Input'; Input: number; type?: 'object' } => {\n\t\t\tif (typeof value === 'function') {\n\t\t\t\treturn this.object(this.add(value as (tx: Transaction) => TransactionObjectArgument));\n\t\t\t}\n\n\t\t\tif (typeof value === 'object' && is(ArgumentSchema, value)) {\n\t\t\t\treturn value as { $kind: 'Input'; Input: number; type?: 'object' };\n\t\t\t}\n\n\t\t\tconst id = getIdFromCallArg(value);\n\n\t\t\tconst inserted = this.#data.inputs.find((i) => id === getIdFromCallArg(i));\n\n\t\t\t// Upgrade shared object inputs to mutable if needed:\n\t\t\tif (\n\t\t\t\tinserted?.Object?.SharedObject &&\n\t\t\t\ttypeof value === 'object' &&\n\t\t\t\tvalue.Object?.SharedObject\n\t\t\t) {\n\t\t\t\tinserted.Object.SharedObject.mutable =\n\t\t\t\t\tinserted.Object.SharedObject.mutable || value.Object.SharedObject.mutable;\n\t\t\t}\n\n\t\t\treturn inserted\n\t\t\t\t? { $kind: 'Input', Input: this.#data.inputs.indexOf(inserted), type: 'object' }\n\t\t\t\t: this.#addInput(\n\t\t\t\t\t\t'object',\n\t\t\t\t\t\ttypeof value === 'string'\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t$kind: 'UnresolvedObject',\n\t\t\t\t\t\t\t\t\tUnresolvedObject: { objectId: normalizeSuiAddress(value) },\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: value,\n\t\t\t\t\t);\n\t\t},\n\t);\n\n\t/**\n\t * Add a new object input to the transaction using the fully-resolved object reference.\n\t * If you only have an object ID, use `builder.object(id)` instead.\n\t */\n\tobjectRef(...args: Parameters<(typeof Inputs)['ObjectRef']>) {\n\t\treturn this.object(Inputs.ObjectRef(...args));\n\t}\n\n\t/**\n\t * Add a new receiving input to the transaction using the fully-resolved object reference.\n\t * If you only have an object ID, use `builder.object(id)` instead.\n\t */\n\treceivingRef(...args: Parameters<(typeof Inputs)['ReceivingRef']>) {\n\t\treturn this.object(Inputs.ReceivingRef(...args));\n\t}\n\n\t/**\n\t * Add a new shared object input to the transaction using the fully-resolved shared object reference.\n\t * If you only have an object ID, use `builder.object(id)` instead.\n\t */\n\tsharedObjectRef(...args: Parameters<(typeof Inputs)['SharedObjectRef']>) {\n\t\treturn this.object(Inputs.SharedObjectRef(...args));\n\t}\n\n\t#fork() {\n\t\tconst fork = new Transaction();\n\n\t\tfork.#data = this.#data;\n\t\tfork.#serializationPlugins = this.#serializationPlugins;\n\t\tfork.#buildPlugins = this.#buildPlugins;\n\t\tfork.#intentResolvers = this.#intentResolvers;\n\t\tfork.#pendingPromises = this.#pendingPromises;\n\t\tfork.#availableResults = new Set(this.#availableResults);\n\t\tfork.#added = this.#added;\n\t\tthis.#inputSection.push(fork.#inputSection);\n\t\tthis.#commandSection.push(fork.#commandSection);\n\n\t\treturn fork;\n\t}\n\n\t/** Add a transaction to the transaction */\n\n\tadd<T extends Command>(command: T): TransactionResult;\n\tadd<T extends void | TransactionResultArgument | TransactionArgument | Command>(\n\t\tthunk: (tx: Transaction) => T,\n\t): T;\n\tadd<T extends TransactionResultArgument | void>(\n\t\tasyncTransactionThunk: AsyncTransactionThunk<T>,\n\t): T;\n\tadd(command: Command | AsyncTransactionThunk | ((tx: Transaction) => unknown)): unknown {\n\t\tif (typeof command === 'function') {\n\t\t\tif (this.#added.has(command)) {\n\t\t\t\treturn this.#added.get(command);\n\t\t\t}\n\n\t\t\tconst fork = this.#fork();\n\t\t\tconst result = command(fork);\n\n\t\t\tif (!(result && typeof result === 'object' && 'then' in result)) {\n\t\t\t\tthis.#availableResults = fork.#availableResults;\n\t\t\t\tthis.#added.set(command, result);\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tconst placeholder = this.#addCommand({\n\t\t\t\t$kind: '$Intent',\n\t\t\t\t$Intent: {\n\t\t\t\t\tname: 'AsyncTransactionThunk',\n\t\t\t\t\tinputs: {},\n\t\t\t\t\tdata: {\n\t\t\t\t\t\tresultIndex: this.#data.commands.length,\n\t\t\t\t\t\tresult: null as TransactionResult | null,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t});\n\n\t\t\tthis.#pendingPromises.add(\n\t\t\t\tPromise.resolve(result as Promise<TransactionResult>).then((result) => {\n\t\t\t\t\tplaceholder.$Intent.data.result = result;\n\t\t\t\t}),\n\t\t\t);\n\t\t\tconst txResult = createTransactionResult(() => placeholder.$Intent.data.resultIndex);\n\t\t\tthis.#added.set(command, txResult);\n\t\t\treturn txResult;\n\t\t} else {\n\t\t\tthis.#addCommand(command);\n\t\t}\n\n\t\treturn createTransactionResult(this.#data.commands.length - 1);\n\t}\n\n\t#addCommand<T extends Command>(command: T) {\n\t\tconst resultIndex = this.#data.commands.length;\n\t\tthis.#commandSection.push(command);\n\t\tthis.#availableResults.add(resultIndex);\n\t\tthis.#data.commands.push(command);\n\n\t\tthis.#data.mapCommandArguments(resultIndex, (arg) => {\n\t\t\tif (arg.$kind === 'Result' && !this.#availableResults.has(arg.Result)) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Result { Result: ${arg.Result} } is not available to use in the current transaction`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (arg.$kind === 'NestedResult' && !this.#availableResults.has(arg.NestedResult[0])) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Result { NestedResult: [${arg.NestedResult[0]}, ${arg.NestedResult[1]}] } is not available to use in the current transaction`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (arg.$kind === 'Input' && arg.Input >= this.#data.inputs.length) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Input { Input: ${arg.Input} } references an input that does not exist in the current transaction`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn arg;\n\t\t});\n\n\t\treturn command;\n\t}\n\n\t#addInput<T extends 'pure' | 'object'>(type: T, input: CallArg) {\n\t\tthis.#inputSection.push(input);\n\t\treturn this.#data.addInput(type, input);\n\t}\n\n\t#normalizeTransactionArgument(arg: TransactionArgument | SerializedBcs<any>) {\n\t\tif (isSerializedBcs(arg)) {\n\t\t\treturn this.pure(arg);\n\t\t}\n\n\t\treturn this.#resolveArgument(arg as TransactionArgument);\n\t}\n\n\t#resolveArgument(arg: TransactionArgument): Argument {\n\t\tif (typeof arg === 'function') {\n\t\t\tconst resolved = this.add(arg as never);\n\n\t\t\tif (typeof resolved === 'function') {\n\t\t\t\treturn this.#resolveArgument(resolved);\n\t\t\t}\n\n\t\t\treturn parse(ArgumentSchema, resolved);\n\t\t}\n\n\t\treturn parse(ArgumentSchema, arg);\n\t}\n\n\t// Method shorthands:\n\n\tsplitCoins<\n\t\tconst Amounts extends (TransactionArgument | SerializedBcs<any> | number | string | bigint)[],\n\t>(coin: TransactionObjectArgument | string, amounts: Amounts) {\n\t\tconst command = TransactionCommands.SplitCoins(\n\t\t\ttypeof coin === 'string' ? this.object(coin) : this.#resolveArgument(coin),\n\t\t\tamounts.map((amount) =>\n\t\t\t\ttypeof amount === 'number' || typeof amount === 'bigint' || typeof amount === 'string'\n\t\t\t\t\t? this.pure.u64(amount)\n\t\t\t\t\t: this.#normalizeTransactionArgument(amount),\n\t\t\t),\n\t\t);\n\t\tthis.#addCommand(command);\n\t\treturn createTransactionResult(this.#data.commands.length - 1, amounts.length) as Extract<\n\t\t\tArgument,\n\t\t\t{ Result: unknown }\n\t\t> & {\n\t\t\t[K in keyof Amounts]: Extract<Argument, { NestedResult: unknown }>;\n\t\t};\n\t}\n\tmergeCoins(\n\t\tdestination: TransactionObjectArgument | string,\n\t\tsources: (TransactionObjectArgument | string)[],\n\t) {\n\t\treturn this.add(\n\t\t\tTransactionCommands.MergeCoins(\n\t\t\t\tthis.object(destination),\n\t\t\t\tsources.map((src) => this.object(src)),\n\t\t\t),\n\t\t);\n\t}\n\tpublish({ modules, dependencies }: { modules: number[][] | string[]; dependencies: string[] }) {\n\t\treturn this.add(\n\t\t\tTransactionCommands.Publish({\n\t\t\t\tmodules,\n\t\t\t\tdependencies,\n\t\t\t}),\n\t\t);\n\t}\n\tupgrade({\n\t\tmodules,\n\t\tdependencies,\n\t\tpackage: packageId,\n\t\tticket,\n\t}: {\n\t\tmodules: number[][] | string[];\n\t\tdependencies: string[];\n\t\tpackage: string;\n\t\tticket: TransactionObjectArgument | string;\n\t}) {\n\t\treturn this.add(\n\t\t\tTransactionCommands.Upgrade({\n\t\t\t\tmodules,\n\t\t\t\tdependencies,\n\t\t\t\tpackage: packageId,\n\t\t\t\tticket: this.object(ticket),\n\t\t\t}),\n\t\t);\n\t}\n\tmoveCall({\n\t\targuments: args,\n\t\t...input\n\t}:\n\t\t| {\n\t\t\t\tpackage: string;\n\t\t\t\tmodule: string;\n\t\t\t\tfunction: string;\n\t\t\t\targuments?: (TransactionArgument | SerializedBcs<any>)[];\n\t\t\t\ttypeArguments?: string[];\n\t\t  }\n\t\t| {\n\t\t\t\ttarget: string;\n\t\t\t\targuments?: (TransactionArgument | SerializedBcs<any>)[];\n\t\t\t\ttypeArguments?: string[];\n\t\t  }) {\n\t\treturn this.add(\n\t\t\tTransactionCommands.MoveCall({\n\t\t\t\t...input,\n\t\t\t\targuments: args?.map((arg) => this.#normalizeTransactionArgument(arg)),\n\t\t\t} as Parameters<typeof TransactionCommands.MoveCall>[0]),\n\t\t);\n\t}\n\ttransferObjects(\n\t\tobjects: (TransactionObjectArgument | string)[],\n\t\taddress: TransactionArgument | SerializedBcs<any> | string,\n\t) {\n\t\treturn this.add(\n\t\t\tTransactionCommands.TransferObjects(\n\t\t\t\tobjects.map((obj) => this.object(obj)),\n\t\t\t\ttypeof address === 'string'\n\t\t\t\t\t? this.pure.address(address)\n\t\t\t\t\t: this.#normalizeTransactionArgument(address),\n\t\t\t),\n\t\t);\n\t}\n\tmakeMoveVec({\n\t\ttype,\n\t\telements,\n\t}: {\n\t\telements: (TransactionObjectArgument | string)[];\n\t\ttype?: string;\n\t}) {\n\t\treturn this.add(\n\t\t\tTransactionCommands.MakeMoveVec({\n\t\t\t\ttype,\n\t\t\t\telements: elements.map((obj) => this.object(obj)),\n\t\t\t}),\n\t\t);\n\t}\n\n\t/**\n\t * Create a FundsWithdrawal input for withdrawing Balance<T> from an address balance accumulator.\n\t * This is used for gas payments from address balances.\n\t *\n\t * @param options.amount - The Amount to withdraw (u64).\n\t * @param options.type - The balance type (e.g., \"0x2::sui::SUI\"). Defaults to SUI.\n\t */\n\twithdrawal({ amount, type }: { amount: number | bigint | string; type?: string | null }): {\n\t\t$kind: 'Input';\n\t\tInput: number;\n\t\ttype?: 'object';\n\t} {\n\t\tconst input: CallArg = {\n\t\t\t$kind: 'FundsWithdrawal',\n\t\t\tFundsWithdrawal: {\n\t\t\t\t// TODO: support entire balance withdrawals once supported\n\t\t\t\treservation: { $kind: 'MaxAmountU64', MaxAmountU64: String(amount) },\n\t\t\t\ttypeArg: { $kind: 'Balance', Balance: type ?? '0x2::sui::SUI' },\n\t\t\t\twithdrawFrom:\n\t\t\t\t\t// fromSponsor === true\n\t\t\t\t\t// \t? { $kind: 'Sponsor', Sponsor: true } :\n\t\t\t\t\t// TODO: currently only supporting withdrawals from sender\n\t\t\t\t\t{ $kind: 'Sender', Sender: true },\n\t\t\t},\n\t\t};\n\n\t\treturn this.#addInput('object', input);\n\t}\n\n\t/**\n\t * @deprecated Use toJSON instead.\n\t * For synchronous serialization, you can use `getData()`\n\t * */\n\tserialize() {\n\t\treturn JSON.stringify(serializeV1TransactionData(this.#data.snapshot()));\n\t}\n\n\tasync toJSON(options: SerializeTransactionOptions = {}): Promise<string> {\n\t\tawait this.prepareForSerialization(options);\n\t\tconst fullyResolved = this.isFullyResolved();\n\t\treturn JSON.stringify(\n\t\t\tparse(\n\t\t\t\tSerializedTransactionDataV2Schema,\n\t\t\t\tfullyResolved\n\t\t\t\t\t? {\n\t\t\t\t\t\t\t...this.#data.snapshot(),\n\t\t\t\t\t\t\tdigest: this.#data.getDigest(),\n\t\t\t\t\t\t}\n\t\t\t\t\t: this.#data.snapshot(),\n\t\t\t),\n\t\t\t(_key, value) => (typeof value === 'bigint' ? value.toString() : value),\n\t\t\t2,\n\t\t);\n\t}\n\n\t/** Build the transaction to BCS bytes, and sign it with the provided keypair. */\n\tasync sign(options: SignOptions): Promise<SignatureWithBytes> {\n\t\tconst { signer, ...buildOptions } = options;\n\t\tconst bytes = await this.build(buildOptions);\n\t\treturn signer.signTransaction(bytes);\n\t}\n\n\t/**\n\t * Checks if the transaction is prepared for serialization to JSON.\n\t * This means:\n\t *  - All async thunks have been fully resolved\n\t *  - All transaction intents have been resolved (unless in supportedIntents)\n\t *\n\t * Unlike `isFullyResolved()`, this does not require the sender, gas payment,\n\t * budget, or object versions to be set.\n\t */\n\tisPreparedForSerialization(options: { supportedIntents?: string[] } = {}) {\n\t\tif (this.#pendingPromises.size > 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (\n\t\t\tthis.#data.commands.some(\n\t\t\t\t(cmd) => cmd.$Intent && !options.supportedIntents?.includes(cmd.$Intent.name),\n\t\t\t)\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t *  Ensures that:\n\t *  - All objects have been fully resolved to a specific version\n\t *  - All pure inputs have been serialized to bytes\n\t *  - All async thunks have been fully resolved\n\t *  - All transaction intents have been resolved\n\t * \t- The gas payment, budget, and price have been set\n\t *  - The transaction sender has been set\n\t *\n\t *  When true, the transaction will always be built to the same bytes and digest (unless the transaction is mutated)\n\t */\n\tisFullyResolved() {\n\t\tif (!this.isPreparedForSerialization()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!this.#data.sender) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (needsTransactionResolution(this.#data, {})) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/** Build the transaction to BCS bytes. */\n\tasync build(options: BuildTransactionOptions = {}): Promise<Uint8Array<ArrayBuffer>> {\n\t\tawait this.prepareForSerialization(options);\n\t\tawait this.#prepareBuild(options);\n\t\treturn this.#data.build({\n\t\t\tonlyTransactionKind: options.onlyTransactionKind,\n\t\t});\n\t}\n\n\t/** Derive transaction digest */\n\tasync getDigest(\n\t\toptions: {\n\t\t\tclient?: ClientWithCoreApi;\n\t\t} = {},\n\t): Promise<string> {\n\t\tawait this.prepareForSerialization(options);\n\t\tawait this.#prepareBuild(options);\n\t\treturn this.#data.getDigest();\n\t}\n\n\t/**\n\t * Prepare the transaction by validating the transaction data and resolving all inputs\n\t * so that it can be built into bytes.\n\t */\n\tasync #prepareBuild(options: BuildTransactionOptions) {\n\t\tif (!options.onlyTransactionKind && !this.#data.sender) {\n\t\t\tthrow new Error('Missing transaction sender');\n\t\t}\n\n\t\tawait this.#runPlugins([...this.#buildPlugins, resolveTransactionPlugin], options);\n\t}\n\n\tasync #runPlugins(plugins: TransactionPlugin[], options: SerializeTransactionOptions) {\n\t\ttry {\n\t\t\tconst createNext = (i: number) => {\n\t\t\t\tif (i >= plugins.length) {\n\t\t\t\t\treturn () => {};\n\t\t\t\t}\n\t\t\t\tconst plugin = plugins[i];\n\n\t\t\t\treturn async () => {\n\t\t\t\t\tconst next = createNext(i + 1);\n\t\t\t\t\tlet calledNext = false;\n\t\t\t\t\tlet nextResolved = false;\n\n\t\t\t\t\tawait plugin(this.#data, options, async () => {\n\t\t\t\t\t\tif (calledNext) {\n\t\t\t\t\t\t\tthrow new Error(`next() was call multiple times in TransactionPlugin ${i}`);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcalledNext = true;\n\n\t\t\t\t\t\tawait next();\n\n\t\t\t\t\t\tnextResolved = true;\n\t\t\t\t\t});\n\n\t\t\t\t\tif (!calledNext) {\n\t\t\t\t\t\tthrow new Error(`next() was not called in TransactionPlugin ${i}`);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!nextResolved) {\n\t\t\t\t\t\tthrow new Error(`next() was not awaited in TransactionPlugin ${i}`);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\n\t\t\tawait createNext(0)();\n\t\t} finally {\n\t\t\tthis.#inputSection = this.#data.inputs.slice();\n\t\t\tthis.#commandSection = this.#data.commands.slice();\n\t\t\tthis.#availableResults = new Set(this.#commandSection.map((_, i) => i));\n\t\t}\n\t}\n\n\tasync #waitForPendingTasks() {\n\t\twhile (this.#pendingPromises.size > 0) {\n\t\t\tconst newPromise = Promise.all(this.#pendingPromises);\n\t\t\tthis.#pendingPromises.clear();\n\t\t\tthis.#pendingPromises.add(newPromise);\n\t\t\tawait newPromise;\n\t\t\tthis.#pendingPromises.delete(newPromise);\n\t\t}\n\t}\n\n\t#sortCommandsAndInputs() {\n\t\tconst unorderedCommands = this.#data.commands;\n\t\tconst unorderedInputs = this.#data.inputs;\n\n\t\tconst orderedCommands = (this.#commandSection as Command[]).flat(Infinity);\n\t\tconst orderedInputs = (this.#inputSection as CallArg[]).flat(Infinity);\n\n\t\tif (orderedCommands.length !== unorderedCommands.length) {\n\t\t\tthrow new Error('Unexpected number of commands found in transaction data');\n\t\t}\n\n\t\tif (orderedInputs.length !== unorderedInputs.length) {\n\t\t\tthrow new Error('Unexpected number of inputs found in transaction data');\n\t\t}\n\n\t\tconst filteredCommands = orderedCommands.filter(\n\t\t\t(cmd) => cmd.$Intent?.name !== 'AsyncTransactionThunk',\n\t\t);\n\n\t\tthis.#data.commands = filteredCommands;\n\t\tthis.#data.inputs = orderedInputs;\n\t\tthis.#commandSection = filteredCommands;\n\t\tthis.#inputSection = orderedInputs;\n\t\tthis.#availableResults = new Set(filteredCommands.map((_, i) => i));\n\n\t\tfunction getOriginalIndex(index: number): number {\n\t\t\tconst command = unorderedCommands[index];\n\t\t\tif (command.$Intent?.name === 'AsyncTransactionThunk') {\n\t\t\t\tconst result = command.$Intent.data.result as TransactionResult | null;\n\n\t\t\t\tif (result == null) {\n\t\t\t\t\tthrow new Error('AsyncTransactionThunk has not been resolved');\n\t\t\t\t}\n\n\t\t\t\treturn getOriginalIndex(result.Result);\n\t\t\t}\n\n\t\t\tconst updated = filteredCommands.indexOf(command);\n\n\t\t\tif (updated === -1) {\n\t\t\t\tthrow new Error('Unable to find original index for command');\n\t\t\t}\n\n\t\t\treturn updated;\n\t\t}\n\n\t\tthis.#data.mapArguments((arg) => {\n\t\t\tif (arg.$kind === 'Input') {\n\t\t\t\tconst updated = orderedInputs.indexOf(unorderedInputs[arg.Input]);\n\n\t\t\t\tif (updated === -1) {\n\t\t\t\t\tthrow new Error('Input has not been resolved');\n\t\t\t\t}\n\n\t\t\t\treturn { ...arg, Input: updated };\n\t\t\t} else if (arg.$kind === 'Result') {\n\t\t\t\tconst updated = getOriginalIndex(arg.Result);\n\n\t\t\t\treturn { ...arg, Result: updated };\n\t\t\t} else if (arg.$kind === 'NestedResult') {\n\t\t\t\tconst updated = getOriginalIndex(arg.NestedResult[0]);\n\n\t\t\t\treturn { ...arg, NestedResult: [updated, arg.NestedResult[1]] };\n\t\t\t}\n\n\t\t\treturn arg;\n\t\t});\n\n\t\tfor (const [i, cmd] of unorderedCommands.entries()) {\n\t\t\tif (cmd.$Intent?.name === 'AsyncTransactionThunk') {\n\t\t\t\ttry {\n\t\t\t\t\tcmd.$Intent.data.resultIndex = getOriginalIndex(i);\n\t\t\t\t} catch {\n\t\t\t\t\t// If async thunk did not return a result, this will error, but is safe to ignore\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tasync prepareForSerialization(options: SerializeTransactionOptions) {\n\t\tawait this.#waitForPendingTasks();\n\t\tthis.#sortCommandsAndInputs();\n\t\tconst intents = new Set<string>();\n\t\tfor (const command of this.#data.commands) {\n\t\t\tif (command.$Intent) {\n\t\t\t\tintents.add(command.$Intent.name);\n\t\t\t}\n\t\t}\n\n\t\tconst steps = [...this.#serializationPlugins];\n\n\t\tfor (const intent of intents) {\n\t\t\tif (options.supportedIntents?.includes(intent)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!this.#intentResolvers.has(intent)) {\n\t\t\t\tthrow new Error(`Missing intent resolver for ${intent}`);\n\t\t\t}\n\n\t\t\tsteps.push(this.#intentResolvers.get(intent)!);\n\t\t}\n\n\t\tsteps.push(namedPackagesPlugin());\n\n\t\tawait this.#runPlugins(steps, options);\n\t}\n}\n"],"mappings":"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"}