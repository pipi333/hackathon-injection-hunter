{"version":3,"file":"TransactionData.mjs","names":["bcs","resolved"],"sources":["../../src/transactions/TransactionData.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toBase58 } from '@mysten/bcs';\nimport type { InferInput } from 'valibot';\nimport { parse } from 'valibot';\n\nimport { bcs } from '../bcs/index.js';\nimport { normalizeSuiAddress } from '../utils/sui-types.js';\nimport type {\n\tArgument,\n\tCallArg,\n\tCommand,\n\tGasData,\n\tTransactionExpiration,\n\tTransactionData,\n} from './data/internal.js';\nimport { ArgumentSchema, TransactionDataSchema } from './data/internal.js';\nimport { transactionDataFromV1 } from './data/v1.js';\nimport type { SerializedTransactionDataV1 } from './data/v1.js';\nimport type { SerializedTransactionDataV2Schema } from './data/v2.js';\nimport { hashTypedData } from './hash.js';\nimport { getIdFromCallArg, remapCommandArguments } from './utils.js';\nimport type { TransactionResult } from './Transaction.js';\nfunction prepareSuiAddress(address: string) {\n\treturn normalizeSuiAddress(address).replace('0x', '');\n}\n\nexport class TransactionDataBuilder implements TransactionData {\n\tstatic fromKindBytes(bytes: Uint8Array) {\n\t\tconst kind = bcs.TransactionKind.parse(bytes);\n\n\t\tconst programmableTx = kind.ProgrammableTransaction;\n\t\tif (!programmableTx) {\n\t\t\tthrow new Error('Unable to deserialize from bytes.');\n\t\t}\n\n\t\treturn TransactionDataBuilder.restore({\n\t\t\tversion: 2,\n\t\t\tsender: null,\n\t\t\texpiration: null,\n\t\t\tgasData: {\n\t\t\t\tbudget: null,\n\t\t\t\towner: null,\n\t\t\t\tpayment: null,\n\t\t\t\tprice: null,\n\t\t\t},\n\t\t\tinputs: programmableTx.inputs,\n\t\t\tcommands: programmableTx.commands,\n\t\t});\n\t}\n\n\tstatic fromBytes(bytes: Uint8Array) {\n\t\tconst rawData = bcs.TransactionData.parse(bytes);\n\t\tconst data = rawData?.V1;\n\t\tconst programmableTx = data.kind.ProgrammableTransaction;\n\n\t\tif (!data || !programmableTx) {\n\t\t\tthrow new Error('Unable to deserialize from bytes.');\n\t\t}\n\n\t\treturn TransactionDataBuilder.restore({\n\t\t\tversion: 2,\n\t\t\tsender: data.sender,\n\t\t\texpiration: data.expiration,\n\t\t\tgasData: data.gasData,\n\t\t\tinputs: programmableTx.inputs,\n\t\t\tcommands: programmableTx.commands,\n\t\t});\n\t}\n\n\tstatic restore(\n\t\tdata:\n\t\t\t| InferInput<typeof SerializedTransactionDataV2Schema>\n\t\t\t| InferInput<typeof SerializedTransactionDataV1>,\n\t) {\n\t\tif (data.version === 2) {\n\t\t\treturn new TransactionDataBuilder(parse(TransactionDataSchema, data));\n\t\t} else {\n\t\t\treturn new TransactionDataBuilder(parse(TransactionDataSchema, transactionDataFromV1(data)));\n\t\t}\n\t}\n\n\t/**\n\t * Generate transaction digest.\n\t *\n\t * @param bytes BCS serialized transaction data\n\t * @returns transaction digest.\n\t */\n\tstatic getDigestFromBytes(bytes: Uint8Array) {\n\t\tconst hash = hashTypedData('TransactionData', bytes);\n\t\treturn toBase58(hash);\n\t}\n\n\tversion = 2 as const;\n\tsender: string | null;\n\texpiration: TransactionExpiration | null;\n\tgasData: GasData;\n\tinputs: CallArg[];\n\tcommands: Command[];\n\n\tconstructor(clone?: TransactionData) {\n\t\tthis.sender = clone?.sender ?? null;\n\t\tthis.expiration = clone?.expiration ?? null;\n\t\tthis.inputs = clone?.inputs ?? [];\n\t\tthis.commands = clone?.commands ?? [];\n\t\tthis.gasData = clone?.gasData ?? {\n\t\t\tbudget: null,\n\t\t\tprice: null,\n\t\t\towner: null,\n\t\t\tpayment: null,\n\t\t};\n\t}\n\n\tbuild({\n\t\tmaxSizeBytes = Infinity,\n\t\toverrides,\n\t\tonlyTransactionKind,\n\t}: {\n\t\tmaxSizeBytes?: number;\n\t\toverrides?: {\n\t\t\texpiration?: TransactionExpiration;\n\t\t\tsender?: string;\n\t\t\tgasData?: Partial<GasData>;\n\t\t};\n\t\tonlyTransactionKind?: boolean;\n\t} = {}) {\n\t\t// TODO validate that inputs and intents are actually resolved\n\t\tconst inputs = this.inputs as (typeof bcs.CallArg.$inferInput)[];\n\t\tconst commands = this.commands as Extract<\n\t\t\tCommand<Exclude<Argument, { IntentResult: unknown } | { NestedIntentResult: unknown }>>,\n\t\t\t{ Upgrade: unknown }\n\t\t>[];\n\n\t\tconst kind = {\n\t\t\tProgrammableTransaction: {\n\t\t\t\tinputs,\n\t\t\t\tcommands,\n\t\t\t},\n\t\t};\n\n\t\tif (onlyTransactionKind) {\n\t\t\treturn bcs.TransactionKind.serialize(kind, { maxSize: maxSizeBytes }).toBytes();\n\t\t}\n\n\t\tconst expiration = overrides?.expiration ?? this.expiration;\n\t\tconst sender = overrides?.sender ?? this.sender;\n\t\tconst gasData = { ...this.gasData, ...overrides?.gasData };\n\n\t\tif (!sender) {\n\t\t\tthrow new Error('Missing transaction sender');\n\t\t}\n\n\t\tif (!gasData.budget) {\n\t\t\tthrow new Error('Missing gas budget');\n\t\t}\n\n\t\tif (!gasData.payment) {\n\t\t\tthrow new Error('Missing gas payment');\n\t\t}\n\n\t\tif (!gasData.price) {\n\t\t\tthrow new Error('Missing gas price');\n\t\t}\n\n\t\tconst transactionData = {\n\t\t\tsender: prepareSuiAddress(sender),\n\t\t\texpiration: expiration ? expiration : { None: true },\n\t\t\tgasData: {\n\t\t\t\tpayment: gasData.payment,\n\t\t\t\towner: prepareSuiAddress(this.gasData.owner ?? sender),\n\t\t\t\tprice: BigInt(gasData.price),\n\t\t\t\tbudget: BigInt(gasData.budget),\n\t\t\t},\n\t\t\tkind: {\n\t\t\t\tProgrammableTransaction: {\n\t\t\t\t\tinputs,\n\t\t\t\t\tcommands,\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\n\t\treturn bcs.TransactionData.serialize(\n\t\t\t{ V1: transactionData },\n\t\t\t{ maxSize: maxSizeBytes },\n\t\t).toBytes();\n\t}\n\n\taddInput<T extends 'object' | 'pure' | 'withdrawal'>(type: T, arg: CallArg) {\n\t\tconst index = this.inputs.length;\n\t\tthis.inputs.push(arg);\n\t\treturn { Input: index, type, $kind: 'Input' as const };\n\t}\n\n\tgetInputUses(index: number, fn: (arg: Argument, command: Command) => void) {\n\t\tthis.mapArguments((arg, command) => {\n\t\t\tif (arg.$kind === 'Input' && arg.Input === index) {\n\t\t\t\tfn(arg, command);\n\t\t\t}\n\n\t\t\treturn arg;\n\t\t});\n\t}\n\n\tmapCommandArguments(\n\t\tindex: number,\n\t\tfn: (arg: Argument, command: Command, commandIndex: number) => Argument,\n\t) {\n\t\tconst command = this.commands[index];\n\n\t\tswitch (command.$kind) {\n\t\t\tcase 'MoveCall':\n\t\t\t\tcommand.MoveCall.arguments = command.MoveCall.arguments.map((arg) =>\n\t\t\t\t\tfn(arg, command, index),\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase 'TransferObjects':\n\t\t\t\tcommand.TransferObjects.objects = command.TransferObjects.objects.map((arg) =>\n\t\t\t\t\tfn(arg, command, index),\n\t\t\t\t);\n\t\t\t\tcommand.TransferObjects.address = fn(command.TransferObjects.address, command, index);\n\t\t\t\tbreak;\n\t\t\tcase 'SplitCoins':\n\t\t\t\tcommand.SplitCoins.coin = fn(command.SplitCoins.coin, command, index);\n\t\t\t\tcommand.SplitCoins.amounts = command.SplitCoins.amounts.map((arg) =>\n\t\t\t\t\tfn(arg, command, index),\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase 'MergeCoins':\n\t\t\t\tcommand.MergeCoins.destination = fn(command.MergeCoins.destination, command, index);\n\t\t\t\tcommand.MergeCoins.sources = command.MergeCoins.sources.map((arg) =>\n\t\t\t\t\tfn(arg, command, index),\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase 'MakeMoveVec':\n\t\t\t\tcommand.MakeMoveVec.elements = command.MakeMoveVec.elements.map((arg) =>\n\t\t\t\t\tfn(arg, command, index),\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase 'Upgrade':\n\t\t\t\tcommand.Upgrade.ticket = fn(command.Upgrade.ticket, command, index);\n\t\t\t\tbreak;\n\t\t\tcase '$Intent':\n\t\t\t\tconst inputs = command.$Intent.inputs;\n\t\t\t\tcommand.$Intent.inputs = {};\n\n\t\t\t\tfor (const [key, value] of Object.entries(inputs)) {\n\t\t\t\t\tcommand.$Intent.inputs[key] = Array.isArray(value)\n\t\t\t\t\t\t? value.map((arg) => fn(arg, command, index))\n\t\t\t\t\t\t: fn(value, command, index);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\tcase 'Publish':\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unexpected transaction kind: ${(command as { $kind: unknown }).$kind}`);\n\t\t}\n\t}\n\n\tmapArguments(fn: (arg: Argument, command: Command, commandIndex: number) => Argument) {\n\t\tfor (const commandIndex of this.commands.keys()) {\n\t\t\tthis.mapCommandArguments(commandIndex, fn);\n\t\t}\n\t}\n\n\treplaceCommand(\n\t\tindex: number,\n\t\treplacement: Command | Command[],\n\t\tresultIndex: number | { Result: number } | { NestedResult: [number, number] } = index,\n\t) {\n\t\tif (!Array.isArray(replacement)) {\n\t\t\tthis.commands[index] = replacement;\n\t\t\treturn;\n\t\t}\n\n\t\tconst sizeDiff = replacement.length - 1;\n\n\t\tthis.commands.splice(index, 1, ...structuredClone(replacement));\n\n\t\tthis.mapArguments((arg, _command, commandIndex) => {\n\t\t\tif (commandIndex < index + replacement.length) {\n\t\t\t\treturn arg;\n\t\t\t}\n\n\t\t\tif (typeof resultIndex !== 'number') {\n\t\t\t\tif (\n\t\t\t\t\t(arg.$kind === 'Result' && arg.Result === index) ||\n\t\t\t\t\t(arg.$kind === 'NestedResult' && arg.NestedResult[0] === index)\n\t\t\t\t) {\n\t\t\t\t\tif (!('NestedResult' in arg) || arg.NestedResult[1] === 0) {\n\t\t\t\t\t\treturn parse(ArgumentSchema, structuredClone(resultIndex));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Cannot replace command ${index} with a specific result type: NestedResult[${index}, ${arg.NestedResult[1]}] references a nested element that cannot be mapped to the replacement result`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Handle adjustment of other references\n\t\t\tswitch (arg.$kind) {\n\t\t\t\tcase 'Result':\n\t\t\t\t\tif (arg.Result === index && typeof resultIndex === 'number') {\n\t\t\t\t\t\targ.Result = resultIndex;\n\t\t\t\t\t}\n\t\t\t\t\tif (arg.Result > index) {\n\t\t\t\t\t\targ.Result += sizeDiff;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'NestedResult':\n\t\t\t\t\tif (arg.NestedResult[0] === index && typeof resultIndex === 'number') {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t$kind: 'NestedResult',\n\t\t\t\t\t\t\tNestedResult: [resultIndex, arg.NestedResult[1]],\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\tif (arg.NestedResult[0] > index) {\n\t\t\t\t\t\targ.NestedResult[0] += sizeDiff;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn arg;\n\t\t});\n\t}\n\n\treplaceCommandWithTransaction(\n\t\tindex: number,\n\t\totherTransaction: TransactionData,\n\t\tresult: TransactionResult,\n\t) {\n\t\tif (result.$kind !== 'Result' && result.$kind !== 'NestedResult') {\n\t\t\tthrow new Error('Result must be of kind Result or NestedResult');\n\t\t}\n\n\t\tthis.insertTransaction(index, otherTransaction);\n\n\t\tthis.replaceCommand(\n\t\t\tindex + otherTransaction.commands.length,\n\t\t\t[],\n\t\t\t'Result' in result\n\t\t\t\t? { NestedResult: [result.Result + index, 0] }\n\t\t\t\t: {\n\t\t\t\t\t\tNestedResult: [\n\t\t\t\t\t\t\t(result as { NestedResult: [number, number] }).NestedResult[0] + index,\n\t\t\t\t\t\t\t(result as { NestedResult: [number, number] }).NestedResult[1],\n\t\t\t\t\t\t] as [number, number],\n\t\t\t\t\t},\n\t\t);\n\t}\n\n\tinsertTransaction(atCommandIndex: number, otherTransaction: TransactionData) {\n\t\tconst inputMapping = new Map<number, number>();\n\t\tconst commandMapping = new Map<number, number>();\n\n\t\tfor (let i = 0; i < otherTransaction.inputs.length; i++) {\n\t\t\tconst otherInput = otherTransaction.inputs[i];\n\t\t\tconst id = getIdFromCallArg(otherInput);\n\n\t\t\tlet existingIndex = -1;\n\t\t\tif (id !== undefined) {\n\t\t\t\texistingIndex = this.inputs.findIndex((input) => getIdFromCallArg(input) === id);\n\n\t\t\t\tif (\n\t\t\t\t\texistingIndex !== -1 &&\n\t\t\t\t\tthis.inputs[existingIndex].Object?.SharedObject &&\n\t\t\t\t\totherInput.Object?.SharedObject\n\t\t\t\t) {\n\t\t\t\t\tthis.inputs[existingIndex].Object!.SharedObject!.mutable =\n\t\t\t\t\t\tthis.inputs[existingIndex].Object!.SharedObject!.mutable ||\n\t\t\t\t\t\totherInput.Object.SharedObject.mutable;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (existingIndex !== -1) {\n\t\t\t\tinputMapping.set(i, existingIndex);\n\t\t\t} else {\n\t\t\t\tconst newIndex = this.inputs.length;\n\t\t\t\tthis.inputs.push(otherInput);\n\t\t\t\tinputMapping.set(i, newIndex);\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = 0; i < otherTransaction.commands.length; i++) {\n\t\t\tcommandMapping.set(i, atCommandIndex + i);\n\t\t}\n\n\t\tconst remappedCommands: Command[] = [];\n\t\tfor (let i = 0; i < otherTransaction.commands.length; i++) {\n\t\t\tconst command = structuredClone(otherTransaction.commands[i]);\n\n\t\t\tremapCommandArguments(command, inputMapping, commandMapping);\n\n\t\t\tremappedCommands.push(command);\n\t\t}\n\n\t\tthis.commands.splice(atCommandIndex, 0, ...remappedCommands);\n\n\t\tconst sizeDiff = remappedCommands.length;\n\t\tif (sizeDiff > 0) {\n\t\t\tthis.mapArguments((arg, _command, commandIndex) => {\n\t\t\t\tif (\n\t\t\t\t\tcommandIndex >= atCommandIndex &&\n\t\t\t\t\tcommandIndex < atCommandIndex + remappedCommands.length\n\t\t\t\t) {\n\t\t\t\t\treturn arg;\n\t\t\t\t}\n\n\t\t\t\tswitch (arg.$kind) {\n\t\t\t\t\tcase 'Result':\n\t\t\t\t\t\tif (arg.Result >= atCommandIndex) {\n\t\t\t\t\t\t\targ.Result += sizeDiff;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'NestedResult':\n\t\t\t\t\t\tif (arg.NestedResult[0] >= atCommandIndex) {\n\t\t\t\t\t\t\targ.NestedResult[0] += sizeDiff;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn arg;\n\t\t\t});\n\t\t}\n\t}\n\n\tgetDigest() {\n\t\tconst bytes = this.build({ onlyTransactionKind: false });\n\t\treturn TransactionDataBuilder.getDigestFromBytes(bytes);\n\t}\n\n\tsnapshot(): TransactionData {\n\t\treturn parse(TransactionDataSchema, this);\n\t}\n\n\tshallowClone() {\n\t\treturn new TransactionDataBuilder({\n\t\t\tversion: this.version,\n\t\t\tsender: this.sender,\n\t\t\texpiration: this.expiration,\n\t\t\tgasData: {\n\t\t\t\t...this.gasData,\n\t\t\t},\n\t\t\tinputs: [...this.inputs],\n\t\t\tcommands: [...this.commands],\n\t\t});\n\t}\n\n\tapplyResolvedData(resolved: TransactionData) {\n\t\tif (!this.sender) {\n\t\t\tthis.sender = resolved.sender ?? null;\n\t\t}\n\n\t\tif (!this.expiration) {\n\t\t\tthis.expiration = resolved.expiration ?? null;\n\t\t}\n\n\t\tif (!this.gasData.budget) {\n\t\t\tthis.gasData.budget = resolved.gasData.budget;\n\t\t}\n\n\t\tif (!this.gasData.owner) {\n\t\t\tthis.gasData.owner = resolved.gasData.owner ?? null;\n\t\t}\n\n\t\tif (!this.gasData.payment) {\n\t\t\tthis.gasData.payment = resolved.gasData.payment;\n\t\t}\n\n\t\tif (!this.gasData.price) {\n\t\t\tthis.gasData.price = resolved.gasData.price;\n\t\t}\n\n\t\tfor (let i = 0; i < this.inputs.length; i++) {\n\t\t\tconst input = this.inputs[i];\n\t\t\tconst resolvedInput = resolved.inputs[i];\n\n\t\t\tswitch (input.$kind) {\n\t\t\t\tcase 'UnresolvedPure':\n\t\t\t\t\tif (resolvedInput.$kind !== 'Pure') {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Expected input at index ${i} to resolve to a Pure argument, but got ${JSON.stringify(\n\t\t\t\t\t\t\t\tresolvedInput,\n\t\t\t\t\t\t\t)}`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tthis.inputs[i] = resolvedInput;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'UnresolvedObject':\n\t\t\t\t\tif (resolvedInput.$kind !== 'Object') {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Expected input at index ${i} to resolve to an Object argument, but got ${JSON.stringify(\n\t\t\t\t\t\t\t\tresolvedInput,\n\t\t\t\t\t\t\t)}`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tresolvedInput.Object.$kind === 'ImmOrOwnedObject' ||\n\t\t\t\t\t\tresolvedInput.Object.$kind === 'Receiving'\n\t\t\t\t\t) {\n\t\t\t\t\t\tconst original = input.UnresolvedObject;\n\t\t\t\t\t\tconst resolved =\n\t\t\t\t\t\t\tresolvedInput.Object.ImmOrOwnedObject ?? resolvedInput.Object.Receiving!;\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tnormalizeSuiAddress(original.objectId) !== normalizeSuiAddress(resolved.objectId) ||\n\t\t\t\t\t\t\t(original.version != null && original.version !== resolved.version) ||\n\t\t\t\t\t\t\t(original.digest != null && original.digest !== resolved.digest) ||\n\t\t\t\t\t\t\t// Objects with shared object properties should not resolve to owned objects\n\t\t\t\t\t\t\toriginal.mutable != null ||\n\t\t\t\t\t\t\toriginal.initialSharedVersion != null\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t`Input at index ${i} did not match unresolved object. ${JSON.stringify(original)} is not compatible with ${JSON.stringify(resolved)}`,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (resolvedInput.Object.$kind === 'SharedObject') {\n\t\t\t\t\t\tconst original = input.UnresolvedObject;\n\t\t\t\t\t\tconst resolved = resolvedInput.Object.SharedObject;\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tnormalizeSuiAddress(original.objectId) !== normalizeSuiAddress(resolved.objectId) ||\n\t\t\t\t\t\t\t(original.initialSharedVersion != null &&\n\t\t\t\t\t\t\t\toriginal.initialSharedVersion !== resolved.initialSharedVersion) ||\n\t\t\t\t\t\t\t(original.mutable != null && original.mutable !== resolved.mutable) ||\n\t\t\t\t\t\t\t// Objects with owned object properties should not resolve to shared objects\n\t\t\t\t\t\t\toriginal.version != null ||\n\t\t\t\t\t\t\toriginal.digest != null\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t`Input at index ${i} did not match unresolved object. ${JSON.stringify(original)} is not compatible with ${JSON.stringify(resolved)}`,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Input at index ${i} resolved to an unexpected Object kind: ${JSON.stringify(\n\t\t\t\t\t\t\t\tresolvedInput.Object,\n\t\t\t\t\t\t\t)}`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.inputs[i] = resolvedInput;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n"],"mappings":"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"}