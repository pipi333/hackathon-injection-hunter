{"version":3,"file":"serial.mjs","names":["#signer","#client","#defaultGasBudget","#gasMode","#cache","#cacheGasCoin","#queue","#buildTransaction","#getValidDuringExpiration","#ensureEpochInfo","#epochInfo","#epochInfoPromise","#fetchEpochInfo"],"sources":["../../../src/transactions/executor/serial.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { bcs } from '../../bcs/index.js';\nimport type { ClientWithCoreApi } from '../../client/core.js';\nimport type { SuiClientTypes } from '../../client/types.js';\nimport type { Signer } from '../../cryptography/keypair.js';\nimport type { ObjectCacheOptions } from '../ObjectCache.js';\nimport { isTransaction, Transaction } from '../Transaction.js';\nimport { CachingTransactionExecutor } from './caching.js';\nimport { SerialQueue } from './queue.js';\n\nconst EPOCH_BOUNDARY_WINDOW = 60_000;\n\ninterface SerialTransactionExecutorBaseOptions extends Omit<ObjectCacheOptions, 'address'> {\n\tclient: ClientWithCoreApi;\n\tsigner: Signer;\n\tdefaultGasBudget?: bigint;\n}\n\nexport interface SerialTransactionExecutorCoinOptions extends SerialTransactionExecutorBaseOptions {\n\tgasMode?: 'coins';\n}\n\nexport interface SerialTransactionExecutorAddressBalanceOptions extends SerialTransactionExecutorBaseOptions {\n\tgasMode: 'addressBalance';\n}\n\nexport type SerialTransactionExecutorOptions =\n\t| SerialTransactionExecutorCoinOptions\n\t| SerialTransactionExecutorAddressBalanceOptions;\n\nexport class SerialTransactionExecutor {\n\t#queue = new SerialQueue();\n\t#signer: Signer;\n\t#client: ClientWithCoreApi;\n\t#cache: CachingTransactionExecutor;\n\t#defaultGasBudget: bigint;\n\t#gasMode: 'coins' | 'addressBalance';\n\t#epochInfo: null | {\n\t\tepoch: string;\n\t\texpiration: number;\n\t\tchainIdentifier: string;\n\t} = null;\n\t#epochInfoPromise: Promise<void> | null = null;\n\n\tconstructor(options: SerialTransactionExecutorOptions) {\n\t\tconst { signer, defaultGasBudget = 50_000_000n, client, cache } = options;\n\t\tthis.#signer = signer;\n\t\tthis.#client = client;\n\t\tthis.#defaultGasBudget = defaultGasBudget;\n\t\tthis.#gasMode = options.gasMode ?? 'coins';\n\t\tthis.#cache = new CachingTransactionExecutor({\n\t\t\tclient,\n\t\t\tcache,\n\t\t\tonEffects: (effects) => this.#cacheGasCoin(effects),\n\t\t});\n\t}\n\n\tasync applyEffects(effects: typeof bcs.TransactionEffects.$inferType) {\n\t\treturn this.#cache.applyEffects(effects);\n\t}\n\n\t#cacheGasCoin = async (effects: typeof bcs.TransactionEffects.$inferType) => {\n\t\tif (this.#gasMode === 'addressBalance' || !effects.V2) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst gasCoin = getGasCoinFromEffects(effects).ref;\n\t\tif (gasCoin) {\n\t\t\tthis.#cache.cache.setCustom('gasCoin', gasCoin);\n\t\t} else {\n\t\t\tthis.#cache.cache.deleteCustom('gasCoin');\n\t\t}\n\t};\n\n\tasync buildTransaction(transaction: Transaction) {\n\t\treturn this.#queue.runTask(() => this.#buildTransaction(transaction));\n\t}\n\n\t#buildTransaction = async (transaction: Transaction) => {\n\t\tawait transaction.prepareForSerialization({\n\t\t\tclient: this.#client,\n\t\t\tsupportedIntents: ['CoinWithBalance'],\n\t\t});\n\t\tconst copy = Transaction.from(transaction);\n\n\t\tif (this.#gasMode === 'addressBalance') {\n\t\t\tcopy.setGasPayment([]);\n\t\t\tcopy.setExpiration(await this.#getValidDuringExpiration());\n\t\t} else {\n\t\t\t// Coin mode: use cached gas coin if available\n\t\t\tconst gasCoin = await this.#cache.cache.getCustom<{\n\t\t\t\tobjectId: string;\n\t\t\t\tversion: string;\n\t\t\t\tdigest: string;\n\t\t\t}>('gasCoin');\n\n\t\t\tif (gasCoin) {\n\t\t\t\tcopy.setGasPayment([gasCoin]);\n\t\t\t}\n\t\t}\n\n\t\tcopy.setGasBudgetIfNotSet(this.#defaultGasBudget);\n\t\tcopy.setSenderIfNotSet(this.#signer.toSuiAddress());\n\n\t\treturn this.#cache.buildTransaction({ transaction: copy });\n\t};\n\n\tasync #getValidDuringExpiration() {\n\t\tawait this.#ensureEpochInfo();\n\t\tconst currentEpoch = BigInt(this.#epochInfo!.epoch);\n\t\treturn {\n\t\t\tValidDuring: {\n\t\t\t\tminEpoch: String(currentEpoch),\n\t\t\t\tmaxEpoch: String(currentEpoch + 1n),\n\t\t\t\tminTimestamp: null,\n\t\t\t\tmaxTimestamp: null,\n\t\t\t\tchain: this.#epochInfo!.chainIdentifier,\n\t\t\t\tnonce: (Math.random() * 0x100000000) >>> 0,\n\t\t\t},\n\t\t};\n\t}\n\n\tasync #ensureEpochInfo(): Promise<void> {\n\t\tif (this.#epochInfo && this.#epochInfo.expiration - EPOCH_BOUNDARY_WINDOW - Date.now() > 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.#epochInfoPromise) {\n\t\t\tawait this.#epochInfoPromise;\n\t\t\treturn;\n\t\t}\n\n\t\tthis.#epochInfoPromise = this.#fetchEpochInfo();\n\t\ttry {\n\t\t\tawait this.#epochInfoPromise;\n\t\t} finally {\n\t\t\tthis.#epochInfoPromise = null;\n\t\t}\n\t}\n\n\tasync #fetchEpochInfo(): Promise<void> {\n\t\tconst [{ systemState }, { chainIdentifier }] = await Promise.all([\n\t\t\tthis.#client.core.getCurrentSystemState(),\n\t\t\tthis.#client.core.getChainIdentifier(),\n\t\t]);\n\n\t\tthis.#epochInfo = {\n\t\t\tepoch: systemState.epoch,\n\t\t\texpiration:\n\t\t\t\tNumber(systemState.epochStartTimestampMs) + Number(systemState.parameters.epochDurationMs),\n\t\t\tchainIdentifier,\n\t\t};\n\t}\n\n\tresetCache() {\n\t\treturn this.#cache.reset();\n\t}\n\n\twaitForLastTransaction() {\n\t\treturn this.#cache.waitForLastTransaction();\n\t}\n\n\texecuteTransaction<Include extends SuiClientTypes.TransactionInclude = {}>(\n\t\ttransaction: Transaction | Uint8Array,\n\t\tinclude?: Include,\n\t\tadditionalSignatures: string[] = [],\n\t): Promise<SuiClientTypes.TransactionResult<Include & { effects: true }>> {\n\t\treturn this.#queue.runTask(async () => {\n\t\t\tconst bytes = isTransaction(transaction)\n\t\t\t\t? await this.#buildTransaction(transaction)\n\t\t\t\t: transaction;\n\n\t\t\tconst { signature } = await this.#signer.signTransaction(bytes);\n\t\t\treturn this.#cache\n\t\t\t\t.executeTransaction({\n\t\t\t\t\tsignatures: [signature, ...additionalSignatures],\n\t\t\t\t\ttransaction: bytes,\n\t\t\t\t\tinclude,\n\t\t\t\t})\n\t\t\t\t.catch(async (error) => {\n\t\t\t\t\tawait this.resetCache();\n\t\t\t\t\tthrow error;\n\t\t\t\t});\n\t\t});\n\t}\n}\n\nexport function getGasCoinFromEffects(effects: typeof bcs.TransactionEffects.$inferType) {\n\tif (!effects.V2) {\n\t\tthrow new Error('Unexpected effects version');\n\t}\n\n\tconst gasObjectChange = effects.V2.changedObjects[effects.V2.gasObjectIndex!];\n\n\tif (!gasObjectChange) {\n\t\tthrow new Error('Gas object not found in effects');\n\t}\n\n\tconst [objectId, { outputState }] = gasObjectChange;\n\n\tif (!outputState.ObjectWrite) {\n\t\tthrow new Error('Unexpected gas object state');\n\t}\n\n\tconst [digest, owner] = outputState.ObjectWrite;\n\n\treturn {\n\t\tref: {\n\t\t\tobjectId,\n\t\t\tdigest,\n\t\t\tversion: effects.V2.lamportVersion,\n\t\t},\n\t\towner: owner.AddressOwner || owner.ObjectOwner!,\n\t};\n}\n"],"mappings":"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"}