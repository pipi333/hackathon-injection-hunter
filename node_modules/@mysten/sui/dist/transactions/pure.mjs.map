{"version":3,"file":"pure.mjs","names":["bcs"],"sources":["../../src/transactions/pure.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { isSerializedBcs } from '@mysten/bcs';\nimport type { SerializedBcs } from '@mysten/bcs';\n\nimport { bcs } from '../bcs/index.js';\nimport { pureBcsSchemaFromTypeName } from '../bcs/pure.js';\nimport type { PureTypeName, ShapeFromPureTypeName, ValidPureTypeName } from '../bcs/pure.js';\n\nexport function createPure<T>(makePure: (value: SerializedBcs<any, any> | Uint8Array) => T) {\n\tfunction pure<Type extends PureTypeName>(\n\t\ttype: Type extends PureTypeName ? ValidPureTypeName<Type> : Type,\n\t\tvalue: ShapeFromPureTypeName<Type>,\n\t): T;\n\n\tfunction pure(\n\t\t/**\n\t\t * The pure value, serialized to BCS. If this is a Uint8Array, then the value\n\t\t * is assumed to be raw bytes, and will be used directly.\n\t\t */\n\t\tvalue: SerializedBcs<any, any> | Uint8Array,\n\t): T;\n\n\tfunction pure(\n\t\ttypeOrSerializedValue?: PureTypeName | SerializedBcs<any, any> | Uint8Array,\n\t\tvalue?: unknown,\n\t): T {\n\t\tif (typeof typeOrSerializedValue === 'string') {\n\t\t\treturn makePure(pureBcsSchemaFromTypeName(typeOrSerializedValue).serialize(value as never));\n\t\t}\n\n\t\tif (typeOrSerializedValue instanceof Uint8Array || isSerializedBcs(typeOrSerializedValue)) {\n\t\t\treturn makePure(typeOrSerializedValue);\n\t\t}\n\n\t\tthrow new Error('tx.pure must be called either a bcs type name, or a serialized bcs value');\n\t}\n\n\tpure.u8 = (value: number) => makePure(bcs.U8.serialize(value));\n\tpure.u16 = (value: number) => makePure(bcs.U16.serialize(value));\n\tpure.u32 = (value: number) => makePure(bcs.U32.serialize(value));\n\tpure.u64 = (value: bigint | number | string) => makePure(bcs.U64.serialize(value));\n\tpure.u128 = (value: bigint | number | string) => makePure(bcs.U128.serialize(value));\n\tpure.u256 = (value: bigint | number | string) => makePure(bcs.U256.serialize(value));\n\tpure.bool = (value: boolean) => makePure(bcs.Bool.serialize(value));\n\tpure.string = (value: string) => makePure(bcs.String.serialize(value));\n\tpure.address = (value: string) => makePure(bcs.Address.serialize(value));\n\tpure.id = pure.address;\n\tpure.vector = <Type extends PureTypeName>(\n\t\ttype: Type extends PureTypeName ? ValidPureTypeName<Type> : Type,\n\t\tvalue: Iterable<ShapeFromPureTypeName<Type>> & { length: number },\n\t) => {\n\t\treturn makePure(\n\t\t\tbcs.vector(pureBcsSchemaFromTypeName(type as PureTypeName)).serialize(value as never),\n\t\t);\n\t};\n\tpure.option = <Type extends PureTypeName>(\n\t\ttype: Type extends PureTypeName ? ValidPureTypeName<Type> : Type,\n\t\tvalue: ShapeFromPureTypeName<Type> | null | undefined,\n\t) => {\n\t\treturn makePure(bcs.option(pureBcsSchemaFromTypeName(type)).serialize(value as never));\n\t};\n\n\treturn pure;\n}\n"],"mappings":";;;;;AAUA,SAAgB,WAAc,UAA8D;CAc3F,SAAS,KACR,uBACA,OACI;AACJ,MAAI,OAAO,0BAA0B,SACpC,QAAO,SAAS,0BAA0B,sBAAsB,CAAC,UAAU,MAAe,CAAC;AAG5F,MAAI,iCAAiC,cAAc,gBAAgB,sBAAsB,CACxF,QAAO,SAAS,sBAAsB;AAGvC,QAAM,IAAI,MAAM,2EAA2E;;AAG5F,MAAK,MAAM,UAAkB,SAASA,OAAI,GAAG,UAAU,MAAM,CAAC;AAC9D,MAAK,OAAO,UAAkB,SAASA,OAAI,IAAI,UAAU,MAAM,CAAC;AAChE,MAAK,OAAO,UAAkB,SAASA,OAAI,IAAI,UAAU,MAAM,CAAC;AAChE,MAAK,OAAO,UAAoC,SAASA,OAAI,IAAI,UAAU,MAAM,CAAC;AAClF,MAAK,QAAQ,UAAoC,SAASA,OAAI,KAAK,UAAU,MAAM,CAAC;AACpF,MAAK,QAAQ,UAAoC,SAASA,OAAI,KAAK,UAAU,MAAM,CAAC;AACpF,MAAK,QAAQ,UAAmB,SAASA,OAAI,KAAK,UAAU,MAAM,CAAC;AACnE,MAAK,UAAU,UAAkB,SAASA,OAAI,OAAO,UAAU,MAAM,CAAC;AACtE,MAAK,WAAW,UAAkB,SAASA,OAAI,QAAQ,UAAU,MAAM,CAAC;AACxE,MAAK,KAAK,KAAK;AACf,MAAK,UACJ,MACA,UACI;AACJ,SAAO,SACNA,OAAI,OAAO,0BAA0B,KAAqB,CAAC,CAAC,UAAU,MAAe,CACrF;;AAEF,MAAK,UACJ,MACA,UACI;AACJ,SAAO,SAASA,OAAI,OAAO,0BAA0B,KAAK,CAAC,CAAC,UAAU,MAAe,CAAC;;AAGvF,QAAO"}