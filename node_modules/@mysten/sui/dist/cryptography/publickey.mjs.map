{"version":3,"file":"publickey.mjs","names":["bcs"],"sources":["../../src/cryptography/publickey.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase64, toBase64 } from '@mysten/bcs';\nimport { blake2b } from '@noble/hashes/blake2.js';\nimport { bytesToHex } from '@noble/hashes/utils.js';\n\nimport { bcs } from '../bcs/index.js';\nimport { normalizeSuiAddress, SUI_ADDRESS_LENGTH } from '../utils/sui-types.js';\nimport type { IntentScope } from './intent.js';\nimport { messageWithIntent } from './intent.js';\nimport { SIGNATURE_FLAG_TO_SCHEME, SIGNATURE_SCHEME_TO_SIZE } from './signature-scheme.js';\n\n/**\n * Value to be converted into public key.\n */\nexport type PublicKeyInitData = string | Uint8Array | Iterable<number>;\n\nexport function bytesEqual(a: Uint8Array, b: Uint8Array) {\n\tif (a === b) return true;\n\n\tif (a.length !== b.length) {\n\t\treturn false;\n\t}\n\n\tfor (let i = 0; i < a.length; i++) {\n\t\tif (a[i] !== b[i]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n/**\n * A public key\n */\nexport abstract class PublicKey {\n\t/**\n\t * Checks if two public keys are equal\n\t */\n\tequals(publicKey: PublicKey) {\n\t\treturn bytesEqual(this.toRawBytes(), publicKey.toRawBytes());\n\t}\n\n\t/**\n\t * Return the base-64 representation of the public key\n\t */\n\ttoBase64() {\n\t\treturn toBase64(this.toRawBytes());\n\t}\n\n\ttoString(): never {\n\t\tthrow new Error(\n\t\t\t'`toString` is not implemented on public keys. Use `toBase64()` or `toRawBytes()` instead.',\n\t\t);\n\t}\n\n\t/**\n\t * Return the Sui representation of the public key encoded in\n\t * base-64. A Sui public key is formed by the concatenation\n\t * of the scheme flag with the raw bytes of the public key\n\t */\n\ttoSuiPublicKey(): string {\n\t\tconst bytes = this.toSuiBytes();\n\t\treturn toBase64(bytes);\n\t}\n\n\tverifyWithIntent(\n\t\tbytes: Uint8Array,\n\t\tsignature: Uint8Array | string,\n\t\tintent: IntentScope,\n\t): Promise<boolean> {\n\t\tconst intentMessage = messageWithIntent(intent, bytes);\n\t\tconst digest = blake2b(intentMessage, { dkLen: 32 });\n\n\t\treturn this.verify(digest, signature);\n\t}\n\n\t/**\n\t * Verifies that the signature is valid for for the provided PersonalMessage\n\t */\n\tverifyPersonalMessage(message: Uint8Array, signature: Uint8Array | string): Promise<boolean> {\n\t\treturn this.verifyWithIntent(\n\t\t\tbcs.byteVector().serialize(message).toBytes(),\n\t\t\tsignature,\n\t\t\t'PersonalMessage',\n\t\t);\n\t}\n\n\t/**\n\t * Verifies that the signature is valid for for the provided Transaction\n\t */\n\tverifyTransaction(transaction: Uint8Array, signature: Uint8Array | string): Promise<boolean> {\n\t\treturn this.verifyWithIntent(transaction, signature, 'TransactionData');\n\t}\n\n\t/**\n\t * Verifies that the public key is associated with the provided address\n\t */\n\tverifyAddress(address: string): boolean {\n\t\treturn this.toSuiAddress() === address;\n\t}\n\n\t/**\n\t * Returns the bytes representation of the public key\n\t * prefixed with the signature scheme flag\n\t */\n\ttoSuiBytes(): Uint8Array<ArrayBuffer> {\n\t\tconst rawBytes = this.toRawBytes();\n\t\tconst suiBytes = new Uint8Array(rawBytes.length + 1);\n\t\tsuiBytes.set([this.flag()]);\n\t\tsuiBytes.set(rawBytes, 1);\n\n\t\treturn suiBytes;\n\t}\n\n\t/**\n\t * Return the Sui address associated with this Ed25519 public key\n\t */\n\ttoSuiAddress(): string {\n\t\t// Each hex char represents half a byte, hence hex address doubles the length\n\t\treturn normalizeSuiAddress(\n\t\t\tbytesToHex(blake2b(this.toSuiBytes(), { dkLen: 32 })).slice(0, SUI_ADDRESS_LENGTH * 2),\n\t\t);\n\t}\n\n\t/**\n\t * Return the byte array representation of the public key\n\t */\n\tabstract toRawBytes(): Uint8Array<ArrayBuffer>;\n\n\t/**\n\t * Return signature scheme flag of the public key\n\t */\n\tabstract flag(): number;\n\n\t/**\n\t * Verifies that the signature is valid for for the provided message\n\t */\n\tabstract verify(data: Uint8Array, signature: Uint8Array | string): Promise<boolean>;\n}\n\nexport function parseSerializedKeypairSignature(serializedSignature: string) {\n\tconst bytes = fromBase64(serializedSignature);\n\n\tconst signatureScheme =\n\t\tSIGNATURE_FLAG_TO_SCHEME[bytes[0] as keyof typeof SIGNATURE_FLAG_TO_SCHEME];\n\n\tswitch (signatureScheme) {\n\t\tcase 'ED25519':\n\t\tcase 'Secp256k1':\n\t\tcase 'Secp256r1':\n\t\t\tconst size =\n\t\t\t\tSIGNATURE_SCHEME_TO_SIZE[signatureScheme as keyof typeof SIGNATURE_SCHEME_TO_SIZE];\n\t\t\tconst signature = bytes.slice(1, bytes.length - size);\n\t\t\tconst publicKey = bytes.slice(1 + signature.length);\n\n\t\t\treturn {\n\t\t\t\tserializedSignature,\n\t\t\t\tsignatureScheme,\n\t\t\t\tsignature,\n\t\t\t\tpublicKey,\n\t\t\t\tbytes,\n\t\t\t};\n\t\tdefault:\n\t\t\tthrow new Error('Unsupported signature scheme');\n\t}\n}\n"],"mappings":";;;;;;;;;AAkBA,SAAgB,WAAW,GAAe,GAAe;AACxD,KAAI,MAAM,EAAG,QAAO;AAEpB,KAAI,EAAE,WAAW,EAAE,OAClB,QAAO;AAGR,MAAK,IAAI,IAAI,GAAG,IAAI,EAAE,QAAQ,IAC7B,KAAI,EAAE,OAAO,EAAE,GACd,QAAO;AAGT,QAAO;;;;;AAMR,IAAsB,YAAtB,MAAgC;;;;CAI/B,OAAO,WAAsB;AAC5B,SAAO,WAAW,KAAK,YAAY,EAAE,UAAU,YAAY,CAAC;;;;;CAM7D,WAAW;AACV,SAAO,SAAS,KAAK,YAAY,CAAC;;CAGnC,WAAkB;AACjB,QAAM,IAAI,MACT,4FACA;;;;;;;CAQF,iBAAyB;AAExB,SAAO,SADO,KAAK,YAAY,CACT;;CAGvB,iBACC,OACA,WACA,QACmB;EAEnB,MAAM,SAAS,QADO,kBAAkB,QAAQ,MAAM,EAChB,EAAE,OAAO,IAAI,CAAC;AAEpD,SAAO,KAAK,OAAO,QAAQ,UAAU;;;;;CAMtC,sBAAsB,SAAqB,WAAkD;AAC5F,SAAO,KAAK,iBACXA,OAAI,YAAY,CAAC,UAAU,QAAQ,CAAC,SAAS,EAC7C,WACA,kBACA;;;;;CAMF,kBAAkB,aAAyB,WAAkD;AAC5F,SAAO,KAAK,iBAAiB,aAAa,WAAW,kBAAkB;;;;;CAMxE,cAAc,SAA0B;AACvC,SAAO,KAAK,cAAc,KAAK;;;;;;CAOhC,aAAsC;EACrC,MAAM,WAAW,KAAK,YAAY;EAClC,MAAM,WAAW,IAAI,WAAW,SAAS,SAAS,EAAE;AACpD,WAAS,IAAI,CAAC,KAAK,MAAM,CAAC,CAAC;AAC3B,WAAS,IAAI,UAAU,EAAE;AAEzB,SAAO;;;;;CAMR,eAAuB;AAEtB,SAAO,oBACN,WAAW,QAAQ,KAAK,YAAY,EAAE,EAAE,OAAO,IAAI,CAAC,CAAC,CAAC,MAAM,GAAG,qBAAqB,EAAE,CACtF;;;AAmBH,SAAgB,gCAAgC,qBAA6B;CAC5E,MAAM,QAAQ,WAAW,oBAAoB;CAE7C,MAAM,kBACL,yBAAyB,MAAM;AAEhC,SAAQ,iBAAR;EACC,KAAK;EACL,KAAK;EACL,KAAK;GACJ,MAAM,OACL,yBAAyB;GAC1B,MAAM,YAAY,MAAM,MAAM,GAAG,MAAM,SAAS,KAAK;AAGrD,UAAO;IACN;IACA;IACA;IACA,WANiB,MAAM,MAAM,IAAI,UAAU,OAAO;IAOlD;IACA;EACF,QACC,OAAM,IAAI,MAAM,+BAA+B"}