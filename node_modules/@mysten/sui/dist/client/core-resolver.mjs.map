{"version":3,"file":"core-resolver.mjs","names":["object"],"sources":["../../src/client/core-resolver.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { parse } from 'valibot';\n\nimport { normalizeSuiAddress, normalizeSuiObjectId, SUI_TYPE_ARG } from '../utils/index.js';\nimport type { ClientWithCoreApi } from './core.js';\nimport { ObjectRefSchema } from '../transactions/data/internal.js';\nimport type { CallArg, Command } from '../transactions/data/internal.js';\nimport type { SuiClientTypes } from './types.js';\nimport { SimulationError } from './errors.js';\nimport { Inputs } from '../transactions/Inputs.js';\nimport { getPureBcsSchema, isTxContext } from '../transactions/serializer.js';\nimport type { TransactionDataBuilder } from '../transactions/TransactionData.js';\nimport { chunk } from '@mysten/utils';\nimport type { BuildTransactionOptions } from '../transactions/index.js';\n\n// The maximum objects that can be fetched at once using multiGetObjects.\nconst MAX_OBJECTS_PER_FETCH = 50;\n\n// An amount of gas (in gas units) that is added to transactions as an overhead to ensure transactions do not fail.\nconst GAS_SAFE_OVERHEAD = 1000n;\nconst MAX_GAS = 50_000_000_000;\n\nfunction getClient(options: BuildTransactionOptions): ClientWithCoreApi {\n\tif (!options.client) {\n\t\tthrow new Error(\n\t\t\t`No sui client passed to Transaction#build, but transaction data was not sufficient to build offline.`,\n\t\t);\n\t}\n\treturn options.client;\n}\n\nexport async function coreClientResolveTransactionPlugin(\n\ttransactionData: TransactionDataBuilder,\n\toptions: BuildTransactionOptions,\n\tnext: () => Promise<void>,\n) {\n\tconst client = getClient(options);\n\n\tawait normalizeInputs(transactionData, client);\n\tawait resolveObjectReferences(transactionData, client);\n\n\tif (!options.onlyTransactionKind) {\n\t\tawait setGasData(transactionData, client);\n\t}\n\n\treturn await next();\n}\n\ninterface SystemStateData {\n\tepoch: string;\n\treferenceGasPrice: string;\n}\n\nasync function setGasData(transactionData: TransactionDataBuilder, client: ClientWithCoreApi) {\n\tlet systemState: SystemStateData | null = null;\n\n\tif (!transactionData.gasData.price) {\n\t\tconst response = await client.core.getCurrentSystemState();\n\t\tsystemState = response.systemState;\n\t\ttransactionData.gasData.price = systemState.referenceGasPrice;\n\t}\n\n\tawait setGasBudget(transactionData, client);\n\tawait setGasPayment(transactionData, client);\n\n\tif (!transactionData.expiration) {\n\t\tawait setExpiration(transactionData, client, systemState);\n\t}\n}\n\nasync function setGasBudget(transactionData: TransactionDataBuilder, client: ClientWithCoreApi) {\n\tif (transactionData.gasData.budget) {\n\t\treturn;\n\t}\n\n\tconst simulateResult = await client.core.simulateTransaction({\n\t\ttransaction: transactionData.build({\n\t\t\toverrides: {\n\t\t\t\tgasData: {\n\t\t\t\t\tbudget: String(MAX_GAS),\n\t\t\t\t\tpayment: [],\n\t\t\t\t},\n\t\t\t},\n\t\t}),\n\t\tinclude: { effects: true },\n\t});\n\n\tif (simulateResult.$kind === 'FailedTransaction') {\n\t\tconst executionError = simulateResult.FailedTransaction.status.error ?? undefined;\n\t\tconst errorMessage = executionError?.message ?? 'Unknown error';\n\t\tthrow new SimulationError(`Transaction resolution failed: ${errorMessage}`, {\n\t\t\tcause: simulateResult,\n\t\t\texecutionError,\n\t\t});\n\t}\n\n\tconst gasUsed = simulateResult.Transaction.effects!.gasUsed;\n\tconst safeOverhead = GAS_SAFE_OVERHEAD * BigInt(transactionData.gasData.price || 1n);\n\n\tconst baseComputationCostWithOverhead = BigInt(gasUsed.computationCost) + safeOverhead;\n\n\tconst gasBudget =\n\t\tbaseComputationCostWithOverhead + BigInt(gasUsed.storageCost) - BigInt(gasUsed.storageRebate);\n\n\ttransactionData.gasData.budget = String(\n\t\tgasBudget > baseComputationCostWithOverhead ? gasBudget : baseComputationCostWithOverhead,\n\t);\n}\n\n// The current default is just picking _all_ coins we can which may not be ideal.\nasync function setGasPayment(transactionData: TransactionDataBuilder, client: ClientWithCoreApi) {\n\tif (!transactionData.gasData.payment) {\n\t\tconst gasPayer = transactionData.gasData.owner ?? transactionData.sender!;\n\t\tlet usesGasCoin = false;\n\t\tlet withdrawals = 0n;\n\n\t\ttransactionData.mapArguments((arg) => {\n\t\t\tif (arg.$kind === 'GasCoin') {\n\t\t\t\tusesGasCoin = true;\n\t\t\t} else if (arg.$kind === 'Input') {\n\t\t\t\tconst input = transactionData.inputs[arg.Input];\n\n\t\t\t\tif (input.$kind === 'FundsWithdrawal') {\n\t\t\t\t\tconst withdrawalOwner = input.FundsWithdrawal.withdrawFrom.Sender\n\t\t\t\t\t\t? transactionData.sender\n\t\t\t\t\t\t: gasPayer;\n\n\t\t\t\t\tif (withdrawalOwner === gasPayer) {\n\t\t\t\t\t\tif (input.FundsWithdrawal.reservation.$kind === 'MaxAmountU64') {\n\t\t\t\t\t\t\twithdrawals += BigInt(input.FundsWithdrawal.reservation.MaxAmountU64);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn arg;\n\t\t});\n\n\t\tconst [suiBalance, coins] = await Promise.all([\n\t\t\tusesGasCoin || !transactionData.gasData.owner\n\t\t\t\t? null\n\t\t\t\t: client.core.getBalance({\n\t\t\t\t\t\towner: transactionData.gasData.owner,\n\t\t\t\t\t}),\n\t\t\tclient.core.listCoins({\n\t\t\t\towner: transactionData.gasData.owner || transactionData.sender!,\n\t\t\t\tcoinType: SUI_TYPE_ARG,\n\t\t\t}),\n\t\t]);\n\n\t\tif (\n\t\t\tsuiBalance?.balance.addressBalance &&\n\t\t\tBigInt(suiBalance.balance.addressBalance) >=\n\t\t\t\tBigInt(transactionData.gasData.budget || '0') + withdrawals\n\t\t) {\n\t\t\ttransactionData.gasData.payment = [];\n\t\t\treturn;\n\t\t}\n\n\t\tconst paymentCoins = coins.objects\n\t\t\t// Filter out coins that are also used as input:\n\t\t\t.filter((coin) => {\n\t\t\t\tconst matchingInput = transactionData.inputs.find((input) => {\n\t\t\t\t\tif (input.Object?.ImmOrOwnedObject) {\n\t\t\t\t\t\treturn coin.objectId === input.Object.ImmOrOwnedObject.objectId;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn false;\n\t\t\t\t});\n\n\t\t\t\treturn !matchingInput;\n\t\t\t})\n\t\t\t.map((coin) =>\n\t\t\t\tparse(ObjectRefSchema, {\n\t\t\t\t\tobjectId: coin.objectId,\n\t\t\t\t\tdigest: coin.digest,\n\t\t\t\t\tversion: coin.version,\n\t\t\t\t}),\n\t\t\t);\n\n\t\tif (!paymentCoins.length) {\n\t\t\tthrow new Error('No valid gas coins found for the transaction.');\n\t\t}\n\n\t\ttransactionData.gasData.payment = paymentCoins;\n\t}\n}\n\nasync function setExpiration(\n\ttransactionData: TransactionDataBuilder,\n\tclient: ClientWithCoreApi,\n\texistingSystemState: SystemStateData | null,\n) {\n\tconst [systemState, { chainIdentifier }] = await Promise.all([\n\t\texistingSystemState ?? client.core.getCurrentSystemState().then((r) => r.systemState),\n\t\tclient.core.getChainIdentifier(),\n\t]);\n\tconst currentEpoch = BigInt(systemState.epoch);\n\n\ttransactionData.expiration = {\n\t\t$kind: 'ValidDuring',\n\t\tValidDuring: {\n\t\t\tminEpoch: String(currentEpoch),\n\t\t\tmaxEpoch: String(currentEpoch + 1n),\n\t\t\tminTimestamp: null,\n\t\t\tmaxTimestamp: null,\n\t\t\tchain: chainIdentifier,\n\t\t\tnonce: (Math.random() * 0x100000000) >>> 0,\n\t\t},\n\t};\n}\n\nasync function resolveObjectReferences(\n\ttransactionData: TransactionDataBuilder,\n\tclient: ClientWithCoreApi,\n) {\n\t// Keep track of the object references that will need to be resolved at the end of the transaction.\n\t// We keep the input by-reference to avoid needing to re-resolve it:\n\tconst objectsToResolve = transactionData.inputs.filter((input) => {\n\t\treturn (\n\t\t\tinput.UnresolvedObject &&\n\t\t\t!(input.UnresolvedObject.version || input.UnresolvedObject?.initialSharedVersion)\n\t\t);\n\t}) as Extract<CallArg, { UnresolvedObject: unknown }>[];\n\n\tconst dedupedIds = [\n\t\t...new Set(\n\t\t\tobjectsToResolve.map((input) => normalizeSuiObjectId(input.UnresolvedObject.objectId)),\n\t\t),\n\t];\n\n\tconst objectChunks = dedupedIds.length ? chunk(dedupedIds, MAX_OBJECTS_PER_FETCH) : [];\n\tconst resolved = (\n\t\tawait Promise.all(\n\t\t\tobjectChunks.map((chunkIds) =>\n\t\t\t\tclient.core.getObjects({\n\t\t\t\t\tobjectIds: chunkIds,\n\t\t\t\t}),\n\t\t\t),\n\t\t)\n\t).flatMap((result) => result.objects);\n\n\tconst responsesById = new Map(\n\t\tdedupedIds.map((id, index) => {\n\t\t\treturn [id, resolved[index]];\n\t\t}),\n\t);\n\n\tconst invalidObjects = Array.from(responsesById)\n\t\t.filter(([_, obj]) => obj instanceof Error)\n\t\t.map(([_, obj]) => (obj as Error).message);\n\n\tif (invalidObjects.length) {\n\t\tthrow new Error(`The following input objects are invalid: ${invalidObjects.join(', ')}`);\n\t}\n\n\tconst objects = resolved.map((object) => {\n\t\tif (object instanceof Error) {\n\t\t\tthrow new Error(`Failed to fetch object: ${object.message}`);\n\t\t}\n\t\tconst owner = object.owner;\n\t\tconst initialSharedVersion =\n\t\t\towner && typeof owner === 'object'\n\t\t\t\t? owner.$kind === 'Shared'\n\t\t\t\t\t? owner.Shared.initialSharedVersion\n\t\t\t\t\t: owner.$kind === 'ConsensusAddressOwner'\n\t\t\t\t\t\t? owner.ConsensusAddressOwner.startVersion\n\t\t\t\t\t\t: null\n\t\t\t\t: null;\n\n\t\treturn {\n\t\t\tobjectId: object.objectId,\n\t\t\tdigest: object.digest,\n\t\t\tversion: object.version,\n\t\t\tinitialSharedVersion,\n\t\t};\n\t});\n\n\tconst objectsById = new Map(\n\t\tdedupedIds.map((id, index) => {\n\t\t\treturn [id, objects[index]];\n\t\t}),\n\t);\n\n\tfor (const [index, input] of transactionData.inputs.entries()) {\n\t\tif (!input.UnresolvedObject) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet updated: CallArg | undefined;\n\t\tconst id = normalizeSuiAddress(input.UnresolvedObject.objectId);\n\t\tconst object = objectsById.get(id);\n\n\t\tif (input.UnresolvedObject.initialSharedVersion ?? object?.initialSharedVersion) {\n\t\t\tupdated = Inputs.SharedObjectRef({\n\t\t\t\tobjectId: id,\n\t\t\t\tinitialSharedVersion:\n\t\t\t\t\tinput.UnresolvedObject.initialSharedVersion || object?.initialSharedVersion!,\n\t\t\t\tmutable: input.UnresolvedObject.mutable || isUsedAsMutable(transactionData, index),\n\t\t\t});\n\t\t} else if (isUsedAsReceiving(transactionData, index)) {\n\t\t\tupdated = Inputs.ReceivingRef(\n\t\t\t\t{\n\t\t\t\t\tobjectId: id,\n\t\t\t\t\tdigest: input.UnresolvedObject.digest ?? object?.digest!,\n\t\t\t\t\tversion: input.UnresolvedObject.version ?? object?.version!,\n\t\t\t\t}!,\n\t\t\t);\n\t\t}\n\n\t\ttransactionData.inputs[transactionData.inputs.indexOf(input)] =\n\t\t\tupdated ??\n\t\t\tInputs.ObjectRef({\n\t\t\t\tobjectId: id,\n\t\t\t\tdigest: input.UnresolvedObject.digest ?? object?.digest!,\n\t\t\t\tversion: input.UnresolvedObject.version ?? object?.version!,\n\t\t\t});\n\t}\n}\n\nasync function normalizeInputs(transactionData: TransactionDataBuilder, client: ClientWithCoreApi) {\n\tconst { inputs, commands } = transactionData;\n\tconst moveCallsToResolve: Extract<Command, { MoveCall: unknown }>['MoveCall'][] = [];\n\tconst moveFunctionsToResolve = new Set<string>();\n\n\tcommands.forEach((command) => {\n\t\t// Special case move call:\n\t\tif (command.MoveCall) {\n\t\t\t// Determine if any of the arguments require encoding.\n\t\t\t// - If they don't, then this is good to go.\n\t\t\t// - If they do, then we need to fetch the normalized move module.\n\n\t\t\t// If we already know the argument types, we don't need to resolve them again\n\t\t\tif (command.MoveCall._argumentTypes) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst inputs = command.MoveCall.arguments.map((arg) => {\n\t\t\t\tif (arg.$kind === 'Input') {\n\t\t\t\t\treturn transactionData.inputs[arg.Input];\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t});\n\t\t\tconst needsResolution = inputs.some(\n\t\t\t\t(input) =>\n\t\t\t\t\tinput?.UnresolvedPure ||\n\t\t\t\t\t(input?.UnresolvedObject && typeof input?.UnresolvedObject.mutable !== 'boolean'),\n\t\t\t);\n\n\t\t\tif (needsResolution) {\n\t\t\t\tconst functionName = `${command.MoveCall.package}::${command.MoveCall.module}::${command.MoveCall.function}`;\n\t\t\t\tmoveFunctionsToResolve.add(functionName);\n\t\t\t\tmoveCallsToResolve.push(command.MoveCall);\n\t\t\t}\n\t\t}\n\t});\n\n\tconst moveFunctionParameters = new Map<string, SuiClientTypes.OpenSignature[]>();\n\tif (moveFunctionsToResolve.size > 0) {\n\t\tawait Promise.all(\n\t\t\t[...moveFunctionsToResolve].map(async (functionName) => {\n\t\t\t\tconst [packageId, moduleName, name] = functionName.split('::');\n\t\t\t\tconst { function: def } = await client.core.getMoveFunction({\n\t\t\t\t\tpackageId,\n\t\t\t\t\tmoduleName,\n\t\t\t\t\tname,\n\t\t\t\t});\n\n\t\t\t\tmoveFunctionParameters.set(functionName, def.parameters);\n\t\t\t}),\n\t\t);\n\t}\n\n\tif (moveCallsToResolve.length) {\n\t\tawait Promise.all(\n\t\t\tmoveCallsToResolve.map(async (moveCall) => {\n\t\t\t\tconst parameters = moveFunctionParameters.get(\n\t\t\t\t\t`${moveCall.package}::${moveCall.module}::${moveCall.function}`,\n\t\t\t\t);\n\n\t\t\t\tif (!parameters) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Entry functions can have a mutable reference to an instance of the TxContext\n\t\t\t\t// struct defined in the TxContext module as the last parameter. The caller of\n\t\t\t\t// the function does not need to pass it in as an argument.\n\t\t\t\tconst hasTxContext = parameters.length > 0 && isTxContext(parameters.at(-1)!);\n\t\t\t\tconst params = hasTxContext ? parameters.slice(0, parameters.length - 1) : parameters;\n\n\t\t\t\tmoveCall._argumentTypes = params;\n\t\t\t}),\n\t\t);\n\t}\n\n\tcommands.forEach((command) => {\n\t\tif (!command.MoveCall) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst moveCall = command.MoveCall;\n\t\tconst fnName = `${moveCall.package}::${moveCall.module}::${moveCall.function}`;\n\t\tconst params = moveCall._argumentTypes;\n\n\t\tif (!params) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (params.length !== command.MoveCall.arguments.length) {\n\t\t\tthrow new Error(`Incorrect number of arguments for ${fnName}`);\n\t\t}\n\n\t\tparams.forEach((param, i) => {\n\t\t\tconst arg = moveCall.arguments[i];\n\t\t\tif (arg.$kind !== 'Input') return;\n\t\t\tconst input = inputs[arg.Input];\n\n\t\t\t// Skip if the input is already resolved\n\t\t\tif (!input.UnresolvedPure && !input.UnresolvedObject) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst inputValue = input.UnresolvedPure?.value ?? input.UnresolvedObject?.objectId!;\n\n\t\t\tconst schema = getPureBcsSchema(param.body);\n\t\t\tif (schema) {\n\t\t\t\targ.type = 'pure';\n\t\t\t\tinputs[inputs.indexOf(input)] = Inputs.Pure(schema.serialize(inputValue));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (typeof inputValue !== 'string') {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Expect the argument to be an object id string, got ${JSON.stringify(\n\t\t\t\t\t\tinputValue,\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\t2,\n\t\t\t\t\t)}`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\targ.type = 'object';\n\t\t\tconst unresolvedObject: typeof input = input.UnresolvedPure\n\t\t\t\t? {\n\t\t\t\t\t\t$kind: 'UnresolvedObject',\n\t\t\t\t\t\tUnresolvedObject: {\n\t\t\t\t\t\t\tobjectId: inputValue,\n\t\t\t\t\t\t},\n\t\t\t\t\t}\n\t\t\t\t: input;\n\n\t\t\tinputs[arg.Input] = unresolvedObject;\n\t\t});\n\t});\n}\n\nfunction isUsedAsMutable(transactionData: TransactionDataBuilder, index: number) {\n\tlet usedAsMutable = false;\n\n\ttransactionData.getInputUses(index, (arg, tx) => {\n\t\tif (tx.MoveCall && tx.MoveCall._argumentTypes) {\n\t\t\tconst argIndex = tx.MoveCall.arguments.indexOf(arg);\n\t\t\tusedAsMutable =\n\t\t\t\ttx.MoveCall._argumentTypes[argIndex].reference !== 'immutable' || usedAsMutable;\n\t\t}\n\n\t\tif (\n\t\t\ttx.$kind === 'MakeMoveVec' ||\n\t\t\ttx.$kind === 'MergeCoins' ||\n\t\t\ttx.$kind === 'SplitCoins' ||\n\t\t\ttx.$kind === 'TransferObjects'\n\t\t) {\n\t\t\tusedAsMutable = true;\n\t\t}\n\t});\n\n\treturn usedAsMutable;\n}\n\nfunction isUsedAsReceiving(transactionData: TransactionDataBuilder, index: number) {\n\tlet usedAsReceiving = false;\n\n\ttransactionData.getInputUses(index, (arg, tx) => {\n\t\tif (tx.MoveCall && tx.MoveCall._argumentTypes) {\n\t\t\tconst argIndex = tx.MoveCall.arguments.indexOf(arg);\n\t\t\tusedAsReceiving = isReceivingType(tx.MoveCall._argumentTypes[argIndex]) || usedAsReceiving;\n\t\t}\n\t});\n\n\treturn usedAsReceiving;\n}\n\nconst RECEIVING_TYPE =\n\t'0x0000000000000000000000000000000000000000000000000000000000000002::transfer::Receiving';\n\nfunction isReceivingType(type: SuiClientTypes.OpenSignature): boolean {\n\tif (type.body.$kind !== 'datatype') {\n\t\treturn false;\n\t}\n\n\treturn type.body.datatype.typeName === RECEIVING_TYPE;\n}\n"],"mappings":"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"}