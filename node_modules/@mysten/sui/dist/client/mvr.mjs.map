{"version":3,"file":"mvr.mjs","names":["#cache","#url","#pageSize","#overrides","#mvrPackageDataLoader","#resolvePackages","#mvrTypeDataLoader","#resolveTypes","#fetch"],"sources":["../../src/client/mvr.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { chunk, DataLoader } from '@mysten/utils';\nimport { isValidNamedPackage, isValidNamedType } from '../utils/move-registry.js';\nimport type { StructTag } from '../utils/sui-types.js';\nimport {\n\tisValidSuiAddress,\n\tnormalizeStructTag,\n\tnormalizeSuiAddress,\n\tparseStructTag,\n} from '../utils/sui-types.js';\nimport type { ClientCache } from './cache.js';\nimport type { TransactionDataBuilder } from '../transactions/TransactionData.js';\nimport { PACKAGE_VERSION } from '../version.js';\nimport type { SuiClientTypes } from './types.js';\n\nconst NAME_SEPARATOR = '/';\nconst MVR_API_HEADER = {\n\t'Mvr-Source': `@mysten/sui@${PACKAGE_VERSION}`,\n};\n\nexport interface MvrClientOptions {\n\tcache: ClientCache;\n\turl?: string;\n\tpageSize?: number;\n\toverrides?: {\n\t\tpackages?: Record<string, string>;\n\t\ttypes?: Record<string, string>;\n\t};\n}\n\nexport class MvrClient implements SuiClientTypes.MvrMethods {\n\t#cache: ClientCache;\n\t#url?: string;\n\t#pageSize: number;\n\t#overrides: {\n\t\tpackages?: Record<string, string>;\n\t\ttypes?: Record<string, string>;\n\t};\n\n\tconstructor({ cache, url, pageSize = 50, overrides }: MvrClientOptions) {\n\t\tthis.#cache = cache;\n\t\tthis.#url = url;\n\t\tthis.#pageSize = pageSize;\n\t\tthis.#overrides = {\n\t\t\tpackages: overrides?.packages,\n\t\t\ttypes: overrides?.types,\n\t\t};\n\n\t\tvalidateOverrides(this.#overrides);\n\t}\n\n\tget #mvrPackageDataLoader() {\n\t\treturn this.#cache.readSync(['#mvrPackageDataLoader', this.#url ?? ''], () => {\n\t\t\tconst loader = new DataLoader<string, string>(async (packages) => {\n\t\t\t\tif (!this.#url) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`MVR Api URL is not set for the current client (resolving ${packages.join(', ')})`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tconst resolved = await this.#resolvePackages(packages);\n\n\t\t\t\treturn packages.map(\n\t\t\t\t\t(pkg) => resolved[pkg] ?? new Error(`Failed to resolve package: ${pkg}`),\n\t\t\t\t);\n\t\t\t});\n\t\t\tconst overrides = this.#overrides?.packages;\n\n\t\t\tif (overrides) {\n\t\t\t\tfor (const [pkg, id] of Object.entries(overrides)) {\n\t\t\t\t\tloader.prime(pkg, id);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn loader;\n\t\t});\n\t}\n\n\tget #mvrTypeDataLoader() {\n\t\treturn this.#cache.readSync(['#mvrTypeDataLoader', this.#url ?? ''], () => {\n\t\t\tconst loader = new DataLoader<string, string>(async (types) => {\n\t\t\t\tif (!this.#url) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`MVR Api URL is not set for the current client (resolving ${types.join(', ')})`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tconst resolved = await this.#resolveTypes(types);\n\n\t\t\t\treturn types.map((type) => resolved[type] ?? new Error(`Failed to resolve type: ${type}`));\n\t\t\t});\n\n\t\t\tconst overrides = this.#overrides?.types;\n\n\t\t\tif (overrides) {\n\t\t\t\tfor (const [type, id] of Object.entries(overrides)) {\n\t\t\t\t\tloader.prime(type, id);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn loader;\n\t\t});\n\t}\n\n\tasync #resolvePackages(packages: readonly string[]) {\n\t\tif (packages.length === 0) return {};\n\n\t\tconst batches = chunk(packages, this.#pageSize);\n\t\tconst results: Record<string, string> = {};\n\n\t\tawait Promise.all(\n\t\t\tbatches.map(async (batch) => {\n\t\t\t\tconst data = await this.#fetch<{ resolution: Record<string, { package_id: string }> }>(\n\t\t\t\t\t'/v1/resolution/bulk',\n\t\t\t\t\t{\n\t\t\t\t\t\tnames: batch,\n\t\t\t\t\t},\n\t\t\t\t);\n\n\t\t\t\tif (!data?.resolution) return;\n\n\t\t\t\tfor (const pkg of Object.keys(data?.resolution)) {\n\t\t\t\t\tconst pkgData = data.resolution[pkg]?.package_id;\n\n\t\t\t\t\tif (!pkgData) continue;\n\n\t\t\t\t\tresults[pkg] = pkgData;\n\t\t\t\t}\n\t\t\t}),\n\t\t);\n\n\t\treturn results;\n\t}\n\n\tasync #resolveTypes(types: readonly string[]) {\n\t\tif (types.length === 0) return {};\n\n\t\tconst batches = chunk(types, this.#pageSize);\n\t\tconst results: Record<string, string> = {};\n\n\t\tawait Promise.all(\n\t\t\tbatches.map(async (batch) => {\n\t\t\t\tconst data = await this.#fetch<{ resolution: Record<string, { type_tag: string }> }>(\n\t\t\t\t\t'/v1/struct-definition/bulk',\n\t\t\t\t\t{\n\t\t\t\t\t\ttypes: batch,\n\t\t\t\t\t},\n\t\t\t\t);\n\n\t\t\t\tif (!data?.resolution) return;\n\n\t\t\t\tfor (const type of Object.keys(data?.resolution)) {\n\t\t\t\t\tconst typeData = data.resolution[type]?.type_tag;\n\t\t\t\t\tif (!typeData) continue;\n\n\t\t\t\t\tresults[type] = typeData;\n\t\t\t\t}\n\t\t\t}),\n\t\t);\n\n\t\treturn results;\n\t}\n\n\tasync #fetch<T>(url: string, body: Record<string, unknown>): Promise<T> {\n\t\tif (!this.#url) {\n\t\t\tthrow new Error('MVR Api URL is not set for the current client');\n\t\t}\n\n\t\tconst response = await fetch(`${this.#url}${url}`, {\n\t\t\tmethod: 'POST',\n\t\t\theaders: {\n\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t...MVR_API_HEADER,\n\t\t\t},\n\t\t\tbody: JSON.stringify(body),\n\t\t});\n\n\t\tif (!response.ok) {\n\t\t\tconst errorBody = await response.json().catch(() => ({}));\n\t\t\tthrow new Error(`Failed to resolve types: ${errorBody?.message}`);\n\t\t}\n\n\t\treturn response.json();\n\t}\n\n\tasync resolvePackage({\n\t\tpackage: name,\n\t}: SuiClientTypes.MvrResolvePackageOptions): Promise<SuiClientTypes.MvrResolvePackageResponse> {\n\t\tif (!hasMvrName(name)) {\n\t\t\treturn {\n\t\t\t\tpackage: name,\n\t\t\t};\n\t\t}\n\t\tconst resolved = await this.#mvrPackageDataLoader.load(name);\n\t\treturn {\n\t\t\tpackage: resolved,\n\t\t};\n\t}\n\n\tasync resolveType({\n\t\ttype,\n\t}: SuiClientTypes.MvrResolveTypeOptions): Promise<SuiClientTypes.MvrResolveTypeResponse> {\n\t\tif (!hasMvrName(type)) {\n\t\t\treturn {\n\t\t\t\ttype,\n\t\t\t};\n\t\t}\n\n\t\tconst mvrTypes = [...extractMvrTypes(type)];\n\t\tconst resolvedTypes = await this.#mvrTypeDataLoader.loadMany(mvrTypes);\n\n\t\tconst typeMap: Record<string, string> = {};\n\n\t\tfor (let i = 0; i < mvrTypes.length; i++) {\n\t\t\tconst resolvedType = resolvedTypes[i];\n\t\t\tif (resolvedType instanceof Error) {\n\t\t\t\tthrow resolvedType;\n\t\t\t}\n\t\t\ttypeMap[mvrTypes[i]] = resolvedType;\n\t\t}\n\n\t\treturn {\n\t\t\ttype: replaceMvrNames(type, typeMap),\n\t\t};\n\t}\n\n\tasync resolve({\n\t\ttypes = [],\n\t\tpackages = [],\n\t}: SuiClientTypes.MvrResolveOptions): Promise<SuiClientTypes.MvrResolveResponse> {\n\t\tconst mvrTypes = new Set<string>();\n\n\t\tfor (const type of types ?? []) {\n\t\t\textractMvrTypes(type, mvrTypes);\n\t\t}\n\n\t\tconst typesArray = [...mvrTypes];\n\t\tconst [resolvedTypes, resolvedPackages] = await Promise.all([\n\t\t\ttypesArray.length > 0 ? this.#mvrTypeDataLoader.loadMany(typesArray) : [],\n\t\t\tpackages.length > 0 ? this.#mvrPackageDataLoader.loadMany(packages) : [],\n\t\t]);\n\n\t\tconst typeMap: Record<string, string> = {\n\t\t\t...this.#overrides?.types,\n\t\t};\n\n\t\tfor (const [i, type] of typesArray.entries()) {\n\t\t\tconst resolvedType = resolvedTypes[i];\n\t\t\tif (resolvedType instanceof Error) {\n\t\t\t\tthrow resolvedType;\n\t\t\t}\n\t\t\ttypeMap[type] = resolvedType;\n\t\t}\n\n\t\tconst replacedTypes: Record<\n\t\t\tstring,\n\t\t\t{\n\t\t\t\ttype: string;\n\t\t\t}\n\t\t> = {};\n\n\t\tfor (const type of types ?? []) {\n\t\t\tconst resolvedType = replaceMvrNames(type, typeMap);\n\n\t\t\treplacedTypes[type] = {\n\t\t\t\ttype: resolvedType,\n\t\t\t};\n\t\t}\n\n\t\tconst replacedPackages: Record<\n\t\t\tstring,\n\t\t\t{\n\t\t\t\tpackage: string;\n\t\t\t}\n\t\t> = {};\n\n\t\tfor (const [i, pkg] of (packages ?? []).entries()) {\n\t\t\tconst resolvedPkg = this.#overrides?.packages?.[pkg] ?? resolvedPackages[i];\n\n\t\t\tif (resolvedPkg instanceof Error) {\n\t\t\t\tthrow resolvedPkg;\n\t\t\t}\n\n\t\t\treplacedPackages[pkg] = {\n\t\t\t\tpackage: resolvedPkg,\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\ttypes: replacedTypes,\n\t\t\tpackages: replacedPackages,\n\t\t};\n\t}\n}\n\nfunction validateOverrides(overrides?: {\n\tpackages?: Record<string, string>;\n\ttypes?: Record<string, string>;\n}) {\n\tif (overrides?.packages) {\n\t\tfor (const [pkg, id] of Object.entries(overrides.packages)) {\n\t\t\tif (!isValidNamedPackage(pkg)) {\n\t\t\t\tthrow new Error(`Invalid package name: ${pkg}`);\n\t\t\t}\n\t\t\tif (!isValidSuiAddress(normalizeSuiAddress(id))) {\n\t\t\t\tthrow new Error(`Invalid package ID: ${id}`);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (overrides?.types) {\n\t\tfor (const [type, val] of Object.entries(overrides.types)) {\n\t\t\t// validate that types are first-level only.\n\t\t\tif (parseStructTag(type).typeParams.length > 0) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'Type overrides must be first-level only. If you want to supply generic types, just pass each type individually.',\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconst parsedValue = parseStructTag(val);\n\n\t\t\tif (!isValidSuiAddress(parsedValue.address)) {\n\t\t\t\tthrow new Error(`Invalid type: ${val}`);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Extracts all named types from a given type.\n */\nexport function extractMvrTypes(type: string | StructTag, types = new Set<string>()) {\n\tif (typeof type === 'string' && !hasMvrName(type)) return types;\n\n\tconst tag = isStructTag(type) ? type : parseStructTag(type);\n\n\tif (hasMvrName(tag.address)) types.add(`${tag.address}::${tag.module}::${tag.name}`);\n\n\tfor (const param of tag.typeParams) {\n\t\textractMvrTypes(param, types);\n\t}\n\n\treturn types;\n}\n\n/**\n * Traverses a type, and replaces any found names with their resolved equivalents,\n * based on the supplied type cache.\n */\nfunction replaceMvrNames(tag: string | StructTag, typeCache: Record<string, string>): string {\n\tconst type = isStructTag(tag) ? tag : parseStructTag(tag);\n\n\tconst typeTag = `${type.address}::${type.module}::${type.name}`;\n\tconst cacheHit = typeCache[typeTag];\n\n\treturn normalizeStructTag({\n\t\t...type,\n\t\taddress: cacheHit ? cacheHit.split('::')[0] : type.address,\n\t\ttypeParams: type.typeParams.map((param) => replaceMvrNames(param, typeCache)),\n\t});\n}\n\nexport function hasMvrName(nameOrType: string) {\n\treturn (\n\t\tnameOrType.includes(NAME_SEPARATOR) || nameOrType.includes('@') || nameOrType.includes('.sui')\n\t);\n}\n\nfunction isStructTag(type: string | StructTag): type is StructTag {\n\treturn (\n\t\ttypeof type === 'object' &&\n\t\t'address' in type &&\n\t\t'module' in type &&\n\t\t'name' in type &&\n\t\t'typeParams' in type\n\t);\n}\n\nexport type NamedPackagesOverrides = {\n\tpackages: Record<string, string>;\n\ttypes: Record<string, string>;\n};\n\n/**\n * Looks up all `.move` names in a transaction block.\n * Returns a list of all the names found.\n */\nexport function findNamesInTransaction(builder: TransactionDataBuilder): {\n\tpackages: string[];\n\ttypes: string[];\n} {\n\tconst packages: Set<string> = new Set();\n\tconst types: Set<string> = new Set();\n\n\tfor (const command of builder.commands) {\n\t\tswitch (command.$kind) {\n\t\t\tcase 'MakeMoveVec':\n\t\t\t\tif (command.MakeMoveVec.type) {\n\t\t\t\t\tgetNamesFromTypeList([command.MakeMoveVec.type]).forEach((type) => {\n\t\t\t\t\t\ttypes.add(type);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'MoveCall':\n\t\t\t\tconst moveCall = command.MoveCall;\n\n\t\t\t\tconst pkg = moveCall.package.split('::')[0];\n\t\t\t\tif (hasMvrName(pkg)) {\n\t\t\t\t\tif (!isValidNamedPackage(pkg)) throw new Error(`Invalid package name: ${pkg}`);\n\t\t\t\t\tpackages.add(pkg);\n\t\t\t\t}\n\n\t\t\t\tgetNamesFromTypeList(moveCall.typeArguments ?? []).forEach((type) => {\n\t\t\t\t\ttypes.add(type);\n\t\t\t\t});\n\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn {\n\t\tpackages: [...packages],\n\t\ttypes: [...types],\n\t};\n}\n\n/**\n * Replace all names & types in a transaction block\n * with their resolved names/types.\n */\nexport function replaceNames(\n\tbuilder: TransactionDataBuilder,\n\tresolved: SuiClientTypes.MvrResolveResponse,\n) {\n\tfor (const command of builder.commands) {\n\t\t// Replacements for `MakeMoveVec` commands (that can include types)\n\t\tif (command.MakeMoveVec?.type) {\n\t\t\tif (!hasMvrName(command.MakeMoveVec.type)) continue;\n\t\t\tif (!resolved.types[command.MakeMoveVec.type])\n\t\t\t\tthrow new Error(`No resolution found for type: ${command.MakeMoveVec.type}`);\n\t\t\tcommand.MakeMoveVec.type = resolved.types[command.MakeMoveVec.type].type;\n\t\t}\n\t\t// Replacements for `MoveCall` commands (that can include packages & types)\n\t\tconst tx = command.MoveCall;\n\t\tif (!tx) continue;\n\n\t\tconst nameParts = tx.package.split('::');\n\t\tconst name = nameParts[0];\n\n\t\tif (hasMvrName(name) && !resolved.packages[name])\n\t\t\tthrow new Error(`No address found for package: ${name}`);\n\n\t\t// Replace package name with address.\n\t\tif (hasMvrName(name)) {\n\t\t\tnameParts[0] = resolved.packages[name].package;\n\t\t\ttx.package = nameParts.join('::');\n\t\t}\n\n\t\tconst types = tx.typeArguments;\n\t\tif (!types) continue;\n\n\t\tfor (let i = 0; i < types.length; i++) {\n\t\t\tif (!hasMvrName(types[i])) continue;\n\n\t\t\tif (!resolved.types[types[i]]) throw new Error(`No resolution found for type: ${types[i]}`);\n\t\t\ttypes[i] = resolved.types[types[i]].type;\n\t\t}\n\n\t\ttx.typeArguments = types;\n\t}\n}\n\n/**\n * Returns a list of unique types that include a name\n * from the given list. This list is retrieved from the Transaction Data.\n */\nfunction getNamesFromTypeList(types: string[]) {\n\tconst names = new Set<string>();\n\tfor (const type of types) {\n\t\tif (hasMvrName(type)) {\n\t\t\tif (!isValidNamedType(type)) throw new Error(`Invalid type with names: ${type}`);\n\t\t\tnames.add(type);\n\t\t}\n\t}\n\treturn names;\n}\n"],"mappings":"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"}